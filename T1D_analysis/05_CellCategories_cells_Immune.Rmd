---
title: "05_CellCategories_cells_Immune"
author: "Nicolas Damond, Nathan Steenbuck"
date: "Created: 23 May, 2022; Compiled: `r format(Sys.time(), '%d %b, %')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
if (rstudioapi::isAvailable()) {
  script_name <- basename(rstudioapi::getSourceEditorContext()$path)
} else {
  script_name <- knitr::current_input()
}

cur_user <- Sys.info()[["user"]]
script_name <- "05_CellCategories_cells_Immune.Rmd"

if (cur_user == "ubuntu") {
  source(file.path("/", "mnt", "central_nas", "projects", 
    "type1_diabetes", "nathan", "T1D_Vol", "T1D_analysis", 
    "analysis", "helpers.R"))
  #n_cores <- future::availableCores() - 1
  n_cores <- 4
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  knitr::opts_knit$set(root_dir = paths$home_data)
  do_print <- FALSE
} else {
  source(file.path("/", "home", "nsteen", "scripts", "T1D_analysis", "analysis", "helpers.R"))
  n_cores <- 8
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  paths$folder_script <- paths$cluster_folder_script
  paths$folder_in <- paths$cluster_folder_in
  paths$folder_out <- paths$cluster_home 
  knitr::opts_knit$set(root_dir = paths$cluster_home)
  do_print <- TRUE
}

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("04_QualityControl", paths$object_type, paths$panel_type, sep = "_")
knitr::opts_chunk$set(echo = TRUE)
```



# **Goal**

In the following scripts, cell types are attributed to all cells in the dataset
in an iterative way:

- `05_CellCategories_cells_Immune` (this script): Attribution of main cell categories 
(immune, islet, exocrine, ...).
- `06_CellTypesImmune_cells_Immune`(this script): Attribution of main cell 
types to immune cells (Lymphocyte, Myeloid, Neutrophil).
- `07_ClustersImmune_cells_Immune`: Further separation of immune cell types 
into clusters.
- `08_CellTypesNonImmune_cells_Immune`: Attribution of cell types
to non-immune cells (Beta, Alpha, Exocrine, ...).
- `08_CellTypesIslet_cells_Immune`: Re-attribution of islet cells
to cell types based on clustering results from the previous step.
- `08_CellTypesIslet_cells_ImmuneII`: Attribution of rare & specific immune cell clusters
like T-reg and T-EMRAs.

Specifically, the goal of this script is to attribute consensus cell categories
(groupings of cells with similar cell types, e.g. "immune", "islet", 
"exocrine").

This is performed in several steps:

1. Unsupervised clustering using two approaches (i) PhenoGraph and (ii) Shared-
nearest neighbors (SNN) + Leiden community detection on two different count 
transformations (`exprs` and `scaled`).

2. For each of the four clustering results (two approaches X two count 
transformations), clusters are manually merged into cell categories based on
marker expression.

3. Consensus cell categories are attributed by majority vote: if the cell 
category is the same for three or more of the four approaches, this category is 
attributed to the cell. If not, the cell is categorized as `ambiguous`.

The resulting cell categories, which are used in downstream analyses are stored
as `colData(spe)$cell_category`.



# **Settings**

## Load packages

```{r packages, results="hide"}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(tictoc),
  library(purrr),
  library(furrr)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paths$prev, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```



# **Clustering**

Unsupervised clustering is performed by generating a nearest-neighbor graph 
followed by community detection (using either Louvain or Leiden algorithms).

## Settings

### Load packages

RPhenoannoy can installed with: `devtools::install_github("stuchly/Rphenoannoy@8b81e2e7fb0599f45070e2cba1b28ac219b7c472")`

```{r packages2, results="hide"}
suppressPackageStartupMessages(c(
  library(ggplot2),
  library(scater),
  library(scuttle),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(ranger),
  library(patchwork),
  library(BiocParallel),
  library(tictoc)
))
```

### Channels and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno1", "Leiden1")

#assay_sel <- c("fastMNN", "scaled")
assay_sel <- c("fastMNN_case_id", "scaled")
names(assay_sel) <- c("exprs", "scaled")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)], 
                        assay_sel[assay_sel %in% reducedDimNames(spe)]))

dimred_sel <- c("UMAP") # , "tSNE")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```

### Select channels to use for clustering

Reduced dimension plots showing marker expression that generated by the previous script 
can be used to select the most relevant markers for clustering.

```{r select-channels-clustering}
channels_clust <- rownames(rowData(spe)[rowData(spe)$clustering == 1, ])
cat(c("\nChannels used for unsupervised clustering:",
      channels_clust[channels_clust %in% rownames(spe)]))
```


## Subset

```{r convert-to-sce}
# Extract the metadata (to avoid conflicts when merging the SCEs)
meta <- metadata(spe)
spatial_coords <- spatialCoords(spe)
colpairs <- colPairs(spe)

# Convert to SingleCellExperiment
sce <- as(spe, "SingleCellExperiment")
remove(spe)
```

Subset the cells for faster processing (`sce_sub`). Cells that were not included are stored in a separate object (`sce_not`).

```{r subset-spe}
if (!("subset" %in% names(meta))) {
  # Cells per case
  nb_cells <- 1000

  # Subset the SPE object (nb_cells per case)
  set.seed(seed)
  cell_subset <- as_tibble(cbind(rn = rownames(colData(sce)),
                                 case_id = colData(sce)$case_id)) |> 
    group_by(case_id) |>
    sample_n(nb_cells, replace = TRUE) |>
    pull(rn) |>
    unique()

  # Keep the subset cell ids in SPE metadata
  meta[["subset"]] <- sort(as.vector(cell_subset))
}

# Keep only the selected cells and channels
sce_sub <- sce[channels_clust, meta[["subset"]]]
sce_not <- sce[channels_clust, !(colnames(sce) %in% colnames(sce_sub))]
```


## **Clustering: PhenoGraph**

Unsupervised clustering is performed with the [PhenoGraph](https://doi.org/10.1016/j.cell.2015.05.047) algorithm. 
This method works by generating a nearest-neighbor (kNN) graph of phenotpyic similarities followed by Louvain community dectection. 

Here, we try the [Rphenoannoy implementation](https://github.com/stuchly/Rphenoannoy).
RPhenoannoy implements a parallel Jaccard-coefficient, approximates the kNN and uses Louvain clustering.

Other implementations such as FastPG were tested, but was eventually dropped to its non-reproducibility.

```{r phenograph-run}
clust_method <- c("Pheno1")

# Number of nearest-neighbors
k <- 30

## Could think of storing results in list and save to .rds.
purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))

  # Run Phenograph
  if (!clust_name %in% colnames(colData(sce_sub))) {
    set.seed(seed)
    ## Try Rphenoannoy. 950 k cells = 17 min!
    tic("Rphenoannoy")
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_sub, cur_assay)), k = k)
    } else {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(reducedDim(sce_sub, cur_assay), k = k)
    }
    toc()

    cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
    colnames(cur_pheno) <- clust_name
    if (cur_assay %in% assayNames(sce_sub)) {
      rownames(cur_pheno) <- colnames(assay(sce_sub, cur_assay))
    } else {
      rownames(cur_pheno) <- rownames(reducedDim(sce_sub, cur_assay))
    }

    # Add Phenograph clusters to the colData of the SCE object
    # Cluster `0` is attributed to non-subsetted cells and not islet cells
    colData(sce_sub)[, clust_name] <<- cur_pheno
    colData(sce_not)[, clust_name] <<- 0
    remove(cur_pheno)
  }
})
```

## **Clustering: SNN + Leiden**

Here, we first construct a shared nearest-neighbor graph and identify clusters using the Leiden community detection algorithm.

### Run clustering

```{r SNN-leiden-run}
clust_method <- c("Leiden1")
do_leiden <- FALSE
plot_clustree <- FALSE

# Number of nearest-neighbors for SNN graph
k <- 15

# Resolutions for Leiden algorithm
resolutions <- c(0.000005, 0.0000075, 0.00001, 0.000025,
                  0.00005,  0.000075,  0.0001,  0.00025,
                   0.0005,   0.00075)

# Iterate over selected Assays.
purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))

  if (!clust_name %in% colnames(colData(sce_sub))) {
    do_leiden <- TRUE
    
    # Build the SNN graph
    # 2 min
    set.seed(seed)
    tic("Build Graph")
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        assay.type = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    } else {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        use.dimred = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    }
    toc()

    # Leiden clustering. 95 k cells = 3 min. 
    # 10 min.
    set.seed(seed)
    tic("Leiden Clustering")
    clusters <- furrr::future_map(resolutions, \(cur_resolution) {
      cur_leiden <- igraph::cluster_leiden(
        cur_graph,
        objective_function = "CPM", # could change for additional scalability.
        resolution_parameter = cur_resolution)

      cur_leiden <- cur_leiden$membership
    }, .options = options)
    toc()

    # Add clusters to colData(spe)
    for (k in seq_along(resolutions)) {
      res_name <- paste(clust_method, cur_assay, k, sep = "_")
      colData(sce_sub)[, res_name] <<- clusters[[k]]
    }

    # Plot cluster tree. This is killed when parallelization is enabled.
    p <- clustree::clustree(sce_sub, prefix = paste0(clust_method, "_", cur_assay, "_"))
    if (do_print) { print(p)}
    # Save.
    fn <- paste0(paste(today, clust_method, cur_assay, "ClusterTree", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param)) 
    remove(cur_graph, clusters)
  }
})
```

### Optimal cluster resolution

Based on the trees above, select the optimal cluster resolution. 
Columns corresponding to other resolutions are removed from `colData(spe)`.

```{r SNN-leiden-select}
do_leiden <- TRUE

if (do_leiden) {
  optimal_res <- c("fastMNN_case_id" = 5, "scaled" = 5)

  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(clust_method, cur_assay, sep = "_")

    optimal_col <- paste(clust_method, cur_assay, optimal_res[cur_assay], sep = "_")
    colData(sce_sub)[, clust_name] <<- colData(sce_sub)[, optimal_col]
    colData(sce_not)[, clust_name] <<- 0

    other_cols <- colnames(colData(sce_sub))[grep(paste0(clust_name, "_"), colnames(colData(sce_sub)))]
    colData(sce_sub)[, other_cols] <<- NULL
  })
}
gc()
```


## **Train classifier**

Clustering is performed on a cell subset. A random forest classifier is used to attribute clusters to the other cells.

### Random forest

Train a random forest classifier to attribute clusters to cells that were not subsetted.

```{r random-forest-train-predict}
#plan(sequential)
if (do_leiden) {
  n_features <- length(channels_clust)

  purrr::walk(assay_sel, \(cur_assay) {
    purrr::walk(methods_sel, \(cur_method) {
      # cur_assay <- assay_sel[1]; cur_method <- methods_sel[1]
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      print(clust_name)

      # Define training (`sce_sub`) and test data (`sce_not`)
      if (cur_assay %in% assayNames(sce_sub)) {
        training_data <- dplyr::bind_cols(t(assay(sce_sub, cur_assay)),
                                          cluster_x = sce_sub[[clust_name]])
        df_data <- t(assay(sce_not, cur_assay))
      } else {
        training_data <- dplyr::bind_cols(reducedDim(sce_sub, cur_assay),
                                          cluster_x = sce_sub[[clust_name]])
        df_data <- reducedDim(sce_not, cur_assay)
      }
      # Changed to dplyr for scalability.
      test_data <- dplyr::bind_cols(df_data, cluster_x = sce_not[[clust_name]])

      # Train
      ranger_model <- ranger::ranger(
        formula = cluster_x ~ .,
        data = training_data,
        importance = "impurity",
        mtry = floor(n_features / 3),
        num.trees = 10 * n_features,
        classification = TRUE,
        num.threads = n_cores,
        seed = seed)

      # Predict
      rf_predict <- predict(ranger_model, test_data, seed = seed)
      sce_not[[clust_name]] <<- rf_predict$predictions
    })
  })
} 
```


### Original vs. predicted

Compare predicted clusters and original clusters on train set (cells on which the clustering algorithms were applied).

```{r random-forest-compare, fig.width=15, fig.height=10}
dat_sub <- scuttle::makePerCellDF(sce_sub, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

dat_not <- scuttle::makePerCellDF(sce_not, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)
dat_not <- dat_not[sample(rownames(dat_not), nrow(dat_sub)), ]

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    dimred_name <- paste("UMAP", cur_assay, sep = "_")
    clust_name <- paste(cur_method, cur_assay, sep = "_")

    # Plot all clusters
    p_sub <- plot_dim_red(dat_sub, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Original", sep = " - "))

    p_not <- plot_dim_red(dat_not, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Predicted", sep = " - "))

    p <- p_sub + p_not
    if (do_print) { print(p) }

    fn <- paste0(paste(today, clust_name, "RFcomparison", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
remove(dat_sub, dat_not, p, p_sub, p_not)
```

### Merge test and train datasets

Merge datasets and add clusters to the SCE object.

```{r random-forest-merge}
# Cluster columns
cluster_cols <- c(outer(methods_sel, assay_sel, FUN = paste, sep = "_"))

# Merge datasets
clusters <- dplyr::bind_rows(as.data.frame(colData(sce_sub)[, cluster_cols]),
                             as.data.frame(colData(sce_not)[, cluster_cols]))
clusters <- clusters[order(match(rownames(clusters), colnames(sce))), ]

# Add to SCE
colData(sce)[, cluster_cols] <- clusters
remove(sce_not)
```


### Save SCE
```{r save-sce}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
message(assayNames(sce))
message(reducedDimNames(sce))
saveRDS(sce, fn_spe)

fn_spe_sub <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_sub.rds"))
message(assayNames(sce_sub))
message(reducedDimNames(sce_sub))
saveRDS(sce_sub, fn_spe_sub)

fn_meta <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_meta.rds"))
saveRDS(meta, fn_meta)

fn_spatial_coords <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_spatial_coords.rds"))
saveRDS(spatial_coords, fn_spatial_coords)

fn_colpairs <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_colpairs.rds"))
saveRDS(colpairs, fn_colpairs)
```
### Load SCE

```{r read-sce-temp}
#fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
#sce <- readRDS(fn_spe)

#fn_spe_sub <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_sub.rds"))
#sce_sub <- readRDS(fn_spe_sub)

#fn_colpairs <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_colpairs.rds"))
#colpairs <- readRDS(fn_colpairs)

#fn_meta <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_meta.rds"))
#meta <- readRDS(fn_meta)

#fn_spatial_coords <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_spatial_coords.rds"))
#spatial_coords <- readRDS(fn_spatial_coords)
```

```{r}
methods_sel <- c("Pheno1", "Leiden1")

#assay_sel <- c("fastMNN", "scaled")
assay_sel <- c("fastMNN_case_id", "scaled")
names(assay_sel) <- c("exprs", "scaled")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(sce_sub)], 
                        assay_sel[assay_sel %in% reducedDimNames(sce_sub)]))

dimred_sel <- c("UMAP") # , "tSNE")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(sce_sub)[!(grepl("DNA|H3", rownames(sce_sub)))]
cat(c("\nChannels:", channels[channels %in% rownames(sce_sub)]))
cat(c("\nNumber of channels:", length(channels)))
channels_clust <- rownames(rowData(sce)[rowData(sce)$clustering == 1, ])
```

# **Visualize clusters**

## Load packages

```{r packages3, results="hide"}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools)#,
  #library(cytomapper)
))
```


## Visualize clusters on reduced dimensions

```{r dimred-clusters}
cur_dat <- makePerCellDF(sce_sub, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)  |> 
  tibble::as_tibble()

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste(cur_method, cur_assay, sep = "_")

      # Plot all clustersdat, dimred, color_by
      p <- plot_dim_red(dat = cur_dat, dimred = dimred_name, color_by = clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) print(p)
      fn <- paste0(paste(today, "Clusters", clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
```


## Distribution of marker expression by cluster

```{r violin-clusters-markers, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
purrr::map(assay_sel, \(cur_assay) {
  purrr::map(methods_sel, \(cur_method) {
    # cur_assay <- assay_sel[2]; cur_method <- methods_sel[1]
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    print(clust_name)
    sce_sub[[clust_name]] <- as.factor(sce_sub[[clust_name]])

    if (cur_assay %in% SummarizedExperiment::assayNames(sce_sub)) {
        cur_dat <- scuttle::makePerCellDF(sce_sub, assay.type = cur_assay,
                                          features = channels_clust, use.dimred = FALSE)
    }

    cur_dat <- melt.data.table(
      as.data.table(cur_dat),
      id.vars = c("image_number", "cell_number", clust_name),
      measure.vars = channels_clust,
      variable.name = "channel",
      value.name = cur_assay
    )
    cur_dat[, MeanExprs := mean(get(cur_assay)),
            by = c("channel", clust_name)]

    p <- plot_violin(cur_dat, x = "channel", y = cur_assay,
                     fill_by = "MeanExprs", facet_by = clust_name,
                     title = clust_name) +
      theme(axis.text.x = element_text(size = 8, angle = 90))
    if (do_print) suppressMessages(print(p))
    fn <- paste0(paste(today, "Clusters", clust_name, "Violins",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```


## Barplot with cluster frequencies
Visualize the number of cells per cluster. 
```{r viz-cluster-barplot}
cur_dat <- scuttle::makePerCellDF(sce, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type) |> 
  tibble::as_tibble()

purrr::walk(methods_sel, \(cur_method) {
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    title <- paste0("Cluster Abundances: ", clust_name)
    df <- cur_dat |> 
      dplyr::select(all_of(clust_name))  |> 
      dplyr::group_by(across(all_of(clust_name))) |> 
      dplyr::summarise(n = n())

    p <- df |> 
      ggplot2::ggplot(ggplot2::aes(x = factor(get(clust_name)),
                                   y = n, fill = factor(get(clust_name)))) +
      mytheme$standard() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        panel.background = ggplot2::element_rect(colour = "grey20")
      ) + 
      ggplot2::geom_bar(stat = "identity") +
      ggtitle(title) + 
      ggplot2::scale_fill_manual(values = palettes$colors[seq_along(unique(cur_dat[[clust_name]]))]) + 
      xlab("Cluster") +
      ylab("Number of cells")
    if (do_print) { print(p) }
    fn <- paste0(paste(today, "Clusters", clust_name, "Barplot",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```

## Heatmap of marker expression by cluster
```{r heatmap-clusters-markers}
hmlist <- list()
n <- 1
names(assay_sel) <- c("counts", "scaled")
purrr::walk(methods_sel, \(cur_method) {
  purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    message(clust_name)
    message(name_cur_assay)
    # Summarize the data

    hm <- summarize_heatmap(sce_sub,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    
    # Display the heatmap
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1
    
    # remove all clusters with less than 10 cells and plot again.
    clust_freq <- table(colData(sce_sub)[[clust_name]])
    keep_clusts <- names(clust_freq)[clust_freq >= 10]
    sce_isl_sub <- sce_sub[, colData(sce_sub)[[clust_name]] %in% keep_clusts]

    hm <- summarize_heatmap(sce_isl_sub,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    # Display the reduced heatmap -> this improves the visualization.
    # Otherwise heatmap is scaled by expression of outliers.
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap_reduced",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1

  })
})
htmltools::tagList(setNames(hmlist, NULL))
names(assay_sel) <- c("exprs", "scaled")
```

## Metadata per cluster
Cell area, in-outside of islets, and number of cells.

```{r metadata-clusters}
keep_meta <- c("cell_area", "cell_eccentricity", "islet_parent", "distance_to_islet", 
               "batch", "donor_type", "age", "gender", "race", "BMI", "case_id")

df <- colData(sce) |> 
  tibble::as_tibble()  |> 
  dplyr::select(any_of(keep_meta), starts_with("Pheno1"), starts_with("Leiden1"))

## Clusters that are inside vs outside. Detect Islet cell clusters!
df |> 
  dplyr::mutate(islet_parent = if_else(islet_parent == 0, "outside", "inside")) |>
  dplyr::group_by(Pheno1_fastMNN_case_id, islet_parent) |> 
  dplyr::summarise(n = n())  |> 
  tidyr::pivot_wider(names_from = islet_parent, values_from = n) |> 
  dplyr::mutate(frac = inside / (inside + outside)) |> 
  dplyr::arrange(desc(frac)) |> 
  print(n = "all")
```

## Visualize clusters with cytomapper

### Select cluster(s) and assay to show

```{r viz-clust-select}
viz_clust <- NULL # c(3, 4, 5, 8, 15, 20) #c(6, 10, 16, 8) #c(1, 2, 3) #NULL
viz_method <- "Pheno1"
viz_assay <- "fastMNN_case_id"
```

### Load images and masks

```{r viz-cluster-load}
if (!is.null(viz_clust)) {
  nb_images <- 14
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")

  # Subset the SCE
  sce_viz <- sce[, colData(sce)[[clust_name]] %in% viz_clust]

  # Select random image.
  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
  min(length(unique(sce_viz$image_fullname)), nb_images)))
  image_sub <- c("6347_Immune_ROI_021.tiff", "6422_Immune_ROI_039.tiff", "6424_Immune_ROI_064.tiff", "6228_Immune_ROI_029.tiff", 
                "8011_Immune_ROI_017.tiff", "6514_Immune_ROI_005.tiff", "6225_Immune_ROI_053.tiff", "6225_Immune_ROI_043.tiff", "6225_Immune_ROI_057.tiff",
                "6328_Immune_ROI_076.tiff", "6328_Immune_ROI_078.tiff", "6328_Immune_ROI_001.tiff",
                "6533_Immune_ROI_051.tiff", "6209_Immune_ROI_057.tiff", "6506_Immune_ROI_060.tiff",
                "6043_Immune_ROI_038.tiff", "6289_Immune_ROI_011.tiff", "6550_Immune_ROI_053.tiff",
                "6285_Immune_ROI_064.tiff", "6324_Immune_ROI_017.tiff")

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")

  # Load images and masks
  images <- yoloader(
    x = sce_viz,
    image_dir = folder_images,
    image_names = image_sub,
    type = "stacks"
  )

  masks <- yoloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )

  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
}
```

### Plot images

Images are saved to disk but not shown.

```{r viz-cluster-plot}
if (!is.null(viz_clust)) {
  fn <- list(filename = file.path(
    plotsave_param$path,
    paste0(paste(today, "Cytomapper", clust_name,
                 paste(viz_clust, collapse = "-"), sep = "_"), ".png")))

  cytomapper::plotPixels(images, object = sce_viz, masks,
                         cell_id = "cell_number", img_id = "ImageName",
                         colour_by = c("SYP", "CD163", "CD204", "CD3e", "PDX1", "CAV1"),
                         outline_by = c(clust_name),
                         bcg = list(SYP = c(0, 5, 1), CD163 = c(0, 5, 1), CD204 = c(0, 5, 1),
                                    CD3e = c(0, 5, 1), PDX1 = c(0, 3, 1), CAV1 = c(0, 3, 1)),
                         image_title = NULL, scale = TRUE, save_plot = fn)
}
```

### Interactive with Cytoviewer

```{r viz-cluster-cytoviewer}
# Use cytoviewer with images, masks and object
# library(cytoviewer)
#if (!is.null(viz_clust)) {
#  channels_view <- channels_clust
#  sub_images <- cytomapper::getChannels(images, channels_view)
#  app <- cytoviewer(image = sub_images, 
#                    mask = masks, 
#                    object = sce_viz[channels_view, ], 
#                    img_id = "ImageName", 
#                    cell_id = "cell_number")

#  if (interactive()) {
#    shiny::runApp(app)
#  }
#}
```

### Remove generated files

```{r viz-cluster-remove}
if (!is.null(viz_clust)) {
  remove(sce_viz, images, masks)
}
```


## Plot specific cluster(s)

When many clusters are present, they may not be easy fo visualize on reduced dimension maps. 
Here, a subset of clusters can be selected for plotting.

### Select cluster(s) and assay to show

```{r dimred-cluster-select}
viz_clust <- NULL # NULL
viz_method <- "Leiden1"
viz_assay <- "fastMNN_case_id"
```

```{r dimred-cluster-plot}
if (!is.null(viz_clust)) {
  # Prepare the data
  cur_dat <- scuttle::makePerCellDF(sce_sub, use.dimred = TRUE) |>
    mutate(case_id = factor(case_id, levels = meta$cases),
           donor_type = factor(donor_type, levels = meta$stages)) |>
    arrange(case_id, donor_type)

  # Clusters and palette
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  clust_nb <-  length(unique(cur_dat[[clust_name]]))
  viz_pal <- palettes$colors[1:clust_nb]
  names(viz_pal) <- 1:clust_nb
  viz_pal[!names(viz_pal) %in% viz_clust] <- "lightgrey"

  # Plot
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, viz_assay, sep = "_")

    p <- plot_dim_red(cur_dat, dimred_name, clust_name, palette = viz_pal,
                      sample = TRUE, size = 0.1, alpha = 1)
    if (do_print) { print(p)}

    fn <- paste0(
      paste(today, paste0("Cluster", paste(viz_clust, collapse = "-")),
            clust_name, cur_dimred, sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
}
```

# **Attribute cell categories**

**Note: this section requires manual intervention**

Here, clusters obtained at the previous steps are manually merged into meaningful cell categories.
Cluster numbers are attributed to the different cell types based on the plots and heatmaps above. 
Consequently, this attribution has to be adapted to the clustering results.

## Cell category attribution

Cell category attribution has to be performed for every combination of clustering methods and selected assays.

### Phenograph x scaled counts

```{r cellcats-pheno-scaled}
clust_methods <- c("Pheno1")
clust_assay <- c("scaled")

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1)
  stop("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_immune <- c(7, 10, 18, 21, 28)
#clust_islet  <- c(9, 11, 16, 17)
#clust_ductal <- c(4, 5, 8, 25, 27)
#clust_acinar <- c(12, 14, 15, 19, 22, 23, 24, 26)
#clust_exocrine <- c(2, 3, 6)
#clust_fibro_endo <- c(1, 20)
#clust_other <- c(13)

clust_immune <- c(9, 14, 16, 26, 27)
clust_islet  <- c(8, 10, 12, 15)
clust_ductal <- c(7, 11, 19, 25)
clust_acinar <- c(2, 4, 20, 22, 23)
clust_exocrine <- c(1, 6, 13)
clust_fibro_endo <- c(5, 18, 24)
clust_other <- c(3, 17, 21)

all_clust <- sort(c(clust_immune, clust_islet, clust_ductal, clust_acinar,
                    clust_exocrine, clust_fibro_endo, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce)[colData(sce)[, clust_name] %in% clust_immune,
             paste("CellCat", clust_name, sep = "_")] <- "Immune"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet,
             paste("CellCat", clust_name, sep = "_")] <- "Islet"
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
             paste("CellCat", clust_name, sep = "_")] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
             paste("CellCat", clust_name, sep = "_")] <- "Acinar"
colData(sce)[colData(sce)[, clust_name] %in% clust_exocrine,
             paste("CellCat", clust_name, sep = "_")] <- "Exocrine"
colData(sce)[colData(sce)[, clust_name] %in% clust_fibro_endo,
             paste("CellCat", clust_name, sep = "_")] <- "Fibro_Endo"
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
             paste("CellCat", clust_name, sep = "_")] <- "Other"
```

### Leiden x scaled counts

```{r cellcats-leiden-scaled}
clust_methods <- c("Leiden1")
clust_assay <- c("scaled")

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1)
  stop("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_immune <- c(13, 14, 18, 23, 30, 35, 38)
#clust_islet  <- c(17, 20, 21, 22)
#clust_acinar <- c(3, 4, 5, 6, 8, 10, 25)
##clust_ductal <- c(7, 9, 12, 15, 16, 29, 40, 41)
#clust_exocrine <- c(2, 19, 28)
#clust_fibro_endo <- c(1, 26, 27)
#clust_other <- c(11, 24, 31, 32, 33, 34, 36, 37, 39, 42, 43)

clust_immune <- c(2, 7, 12, 17)
clust_islet  <- c(9, 11)
clust_acinar <- c(3, 14, 15)
clust_ductal <- c(6, 8, 10, 18, 24, 25, 27, 28, 30, 31)
clust_exocrine <- c()
clust_fibro_endo <- c(1, 5)
clust_other <- c(4, 13, 16, 19, 20, 21, 22, 23, 26, 29)

all_clust <- sort(c(clust_immune, clust_islet, clust_ductal, clust_acinar,
                    clust_exocrine, clust_fibro_endo, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce)[colData(sce)[, clust_name] %in% clust_immune,
             paste("CellCat", clust_name, sep = "_")] <- "Immune"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet,
             paste("CellCat", clust_name, sep = "_")] <- "Islet"
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
             paste("CellCat", clust_name, sep = "_")] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
             paste("CellCat", clust_name, sep = "_")] <- "Acinar"
colData(sce)[colData(sce)[, clust_name] %in% clust_exocrine,
             paste("CellCat", clust_name, sep = "_")] <- "Exocrine"
colData(sce)[colData(sce)[, clust_name] %in% clust_fibro_endo,
             paste("CellCat", clust_name, sep = "_")] <- "Fibro_Endo"
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
             paste("CellCat", clust_name, sep = "_")] <- "Other"
```

### Phenograph x fastMNN counts

```{r cellcats-pheno-fastMNN}
clust_methods <- c("Pheno1")
clust_assay <- c("fastMNN_case_id")

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1)
  stop("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_immune <- c(2, 9, 17, 23)
#clust_islet  <- c(12, 13, 14, 16)
##clust_acinar <- c(3, 4, 5, 10, 15, 21, 20, 22)
#clust_ductal <- c(6, 7, 8)
#clust_exocrine <- c()
#clust_fibro_endo <- c(1, 18, 19)
#clust_other <- c(11, 24)

clust_islet  <- c(9, 17, 18)
clust_immune <- c(1, 12, 13, 22)
clust_fibro_endo <- c(11, 16, 21)
clust_ductal <- c(6, 7, 10, 14)
clust_acinar <- c(3, 4, 5, 8, 15, 20)
clust_exocrine <- c(2, 19)
clust_other <- c(23)

all_clust <- sort(c(clust_immune, clust_islet, clust_ductal, clust_acinar,
                    clust_exocrine, clust_fibro_endo, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
     any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce)[colData(sce)[, clust_name] %in% clust_immune,
             paste("CellCat", clust_name, sep = "_")] <- "Immune"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet,
             paste("CellCat", clust_name, sep = "_")] <- "Islet"
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
             paste("CellCat", clust_name, sep = "_")] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
             paste("CellCat", clust_name, sep = "_")] <- "Acinar"
colData(sce)[colData(sce)[, clust_name] %in% clust_exocrine,
             paste("CellCat", clust_name, sep = "_")] <- "Exocrine"
colData(sce)[colData(sce)[, clust_name] %in% clust_fibro_endo,
             paste("CellCat", clust_name, sep = "_")] <- "Fibro_Endo"
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
             paste("CellCat", clust_name, sep = "_")] <- "Other"
```

### Leiden1 x fastMNN counts

```{r cellcats-leiden-fastMNN}
clust_methods <- c("Leiden1")
clust_assay <- c("fastMNN_case_id")

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")
if (length(clust_assay) != 1)
  stop("Select only one assay")

clust_name <- paste(clust_methods, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_immune <- c(11, 17, 20, 25, 26, 27)
#clust_islet  <- c(13, 16, 18)
#clust_ductal <- c(7, 8, 9, 10)
#clust_acinar <- c(2, 3, 4, 5, 6, 12, 15, 21)
#clust_exocrine <- c()
#clust_fibro_endo <- c(1, 19)
#clust_other <- c(14, 22, 23, 24, 28)

clust_immune <- c(1, 11, 12, 13, 21)
clust_islet  <- c(9, 15, 19)
clust_fibro_endo <- c(5, 22)
clust_acinar <- c(3, 4, 6)
clust_ductal <- c(7)
clust_other <- c(16, 17, 18, 20, 23)
clust_exocrine <- c(2, 8, 10, 14)

all_clust <- sort(c(clust_immune, clust_islet, clust_ductal, clust_acinar,
                    clust_exocrine, clust_fibro_endo, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce)[colData(sce)[, clust_name] %in% clust_immune,
             paste("CellCat", clust_name, sep = "_")] <- "Immune"
colData(sce)[colData(sce)[, clust_name] %in% clust_islet,
             paste("CellCat", clust_name, sep = "_")] <- "Islet"
colData(sce)[colData(sce)[, clust_name] %in% clust_ductal,
             paste("CellCat", clust_name, sep = "_")] <- "Ductal"
colData(sce)[colData(sce)[, clust_name] %in% clust_acinar,
             paste("CellCat", clust_name, sep = "_")] <- "Acinar"
colData(sce)[colData(sce)[, clust_name] %in% clust_exocrine,
             paste("CellCat", clust_name, sep = "_")] <- "Exocrine"
colData(sce)[colData(sce)[, clust_name] %in% clust_fibro_endo,
             paste("CellCat", clust_name, sep = "_")] <- "Fibro_Endo"
colData(sce)[colData(sce)[, clust_name] %in% clust_other,
             paste("CellCat", clust_name, sep = "_")] <- "Other"
```


## Visualize attributed categories

```{r assay-sel}
assay_sel <- c("fastMNN_case_id", "scaled")
names(assay_sel) <- c("exprs", "scaled")
```

### Plot cell types on reduced dimensions


```{r cellcats-dimred}
# Prepare the data
cur_dat <- makePerCellDF(sce[, metadata(sce)$subset], use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = metadata(sce)$cases),
         donor_type = factor(donor_type, levels = metadata(sce)$stages)) |>
  arrange(case_id, donor_type)

# Plot
purrr::map(assay_sel, \(cur_assay) {
  purrr::map(dimred_sel, \(cur_dimred) {
    purrr::map(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste("CellCat", cur_method, cur_assay,
                          sep = "_")

      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) { print(p)}

      fn <- paste0(paste(today, clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
```

### Cell categories heatmap

```{r cellcats-heatmap}
hmlist <- list()
n <- 1
purrr::map2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  purrr::map(methods_sel, \(cur_method) {
    clust_name <- paste("CellCat", cur_method, cur_assay, sep = "_")

    # Summarize the data
    hm <- summarize_heatmap(sce[, meta$subset],
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)

    # Display the heatmap
    fn <- paste0(paste(today, clust_name, "Heatmap",
                       sep = "_"), ".html")

    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize categories with cytomapper

Load the masks

```{r viz-cellcats-load}
nb_images <- 14
image_extension <- ".tiff"
# clust_name <- paste(viz_method, viz_assay, sep = "_")

set.seed(seed)
image_sub <- sort(sample(
  unique(sce$image_fullname),
  min(length(unique(sce$image_fullname)), nb_images)))

# Subset the SCE to subsampled images
sce_sub <- sce[, sce$image_fullname %in% image_sub]
sce_sub$ImageName <- gsub(image_extension, "", sce_sub$image_fullname)

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Load masks
masks <- yoloader(
  x = sce_sub,
  image_dir = folder_masks,
  image_names = image_sub,
  as.is = TRUE,
  type = "masks"
)
```

Plot the images

```{r viz-cellcats-plot}
purrr::map(assay_sel, \(cur_assay) {
  purrr::map(methods_sel, \(cur_method) {
    celltype_viz <- paste("CellCat", cur_method, cur_assay,
                          sep = "_")

    colour_key <- list(c(
      Immune = palettes$colors[1], Islet = palettes$colors[8],
      Ductal = palettes$colors[5], Acinar = palettes$colors[4],
      Exocrine = palettes$colors[3], Fibro_Endo = palettes$colors[11],
      Other = palettes$colors[13]))
    names(colour_key) <- celltype_viz

    fn <- list(filename = file.path(
      plotsave_param$path,
      paste0(paste(today, "Cytomapper", celltype_viz, sep = "_"), ".png")))

    cytomapper::plotCells(masks, object = sce_sub,
              cell_id = "cell_number", img_id = "ImageName",
              colour_by = celltype_viz, colour = colour_key, save_plot = fn)
  })
})
```



# **Consensus cell categories**

Attribute consensus cell categories based on the clustering performed in the previous script.

## Load packages

```{r packages4, results="hide"}
suppressPackageStartupMessages(c(
  library(ggalluvial)
))
```


## Attribute temporary cell types

Exocrine cells are grouped into a single category and the ductal/acinar types are stored into temporary cell types.
For the other cells, the attributed cell type corresponds to the cell category. 
Precise cell types will be refined in downstream scripts.

```{r attribute-celltypes}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    celltype_name <- paste("CellType", clust_name, sep = "_")
    cellcat_name <- paste("CellCat", clust_name, sep = "_")

    colData(sce)[, celltype_name] <<- colData(sce)[, cellcat_name]

    colData(sce)[colData(sce)[, cellcat_name] %in% c(
      "Exocrine", "Acinar", "Ductal"), cellcat_name] <<- "exocrine"
    colData(sce)[colData(sce)[, cellcat_name] == "Immune",
                 cellcat_name] <<- "immune"
    colData(sce)[colData(sce)[, cellcat_name] == "Islet",
                 cellcat_name] <<- "islet"
    colData(sce)[colData(sce)[, cellcat_name] == "Fibro_Endo",
                 cellcat_name] <<- "mesenchymal_endothelial"
    colData(sce)[colData(sce)[, cellcat_name] == "Other",
                 cellcat_name] <<- "other"
  })
})
```


## Cell category concordance

Compare concordance of cell categories attributed using different methods.

```{r cellcats-concordance}
cellcat_cols <- colnames(colData(sce))[grepl(paste0(
  "CellCat_", methods_sel, collapse = "|"), colnames(colData(sce)))]

cell_categories <- as.data.table(colData(sce)[
  , c("cell_id", "case_id", "image_number", "cell_number", cellcat_cols)])

ccat_combination <- t(combn(unique(cellcat_cols), 2))

for (i in seq_len(nrow(ccat_combination))) {
  cat("\n", ccat_combination[i, 1], " vs ", ccat_combination[i, 2], "\n")

  ccat_concord <- nrow(cell_categories[
    get(ccat_combination[i, 1]) == get(ccat_combination[i, 2]), ]
  )
  ccat_discord <- nrow(cell_categories[
    get(ccat_combination[i, 1]) != get(ccat_combination[i, 2]), ]
  )
  cat("Number of cells with concordant cell categories: ", ccat_concord,
      "\nNumber of cells with discordant cell categories: ", ccat_discord,
      "\nPercentage of cells with concordant cell categories:",
      100 * ccat_concord / (ccat_discord + ccat_concord), "%", "\n")
}
```
Pheno1-scaled vs Leiden1-fastMNN: 79% (88%)
Pheno1-scaled vs Pheno1-fastMNN: 74% (83%)
Pheno1-scaled vs Leiden1-scaled: 91.2 % (92.6%)
Leiden1-fastMNN vs Pheno1-fastMNN: 77 % (88%)
Pheno1-fastMNN vs Leiden1-scaled: 72 % (82%)
Leiden1-fastMNN vs Leiden1-scaled: 74 % (85 %)

## Attribute consensus cell categories

### Majority vote

Here, we remove Pheno1-fastMNN. 
Cells for which 2 out of 3 methods agree on the cell categories are attributed this category, other cells as considered as "ambiguous".

```{r consensus-cell-categories}
# Remove a column matching "Pheno1_fastMNN"
# Use grep to find the column that matches the pattern "Pheno1-fastMNN"
column_to_remove <- grep("Pheno1_fastMNN", names(cell_categories))

# Remove the column by setting it to NULL
cell_categories[, (column_to_remove) := NULL]

# Majority vote
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

cell_categories[, cell_category := apply(cell_categories, 1, Mode)]
cell_categories[, Paste := do.call(paste0, .SD),
                .SDcols = grep("CellCat_", colnames(cell_categories))]
cell_categories[, count := stringr::str_count(Paste, cell_category)]
cell_categories[count < 2, cell_category := "ambiguous"]
cell_categories[, `:=`(Paste = NULL, count = NULL)]

cat("Percentage of cells with an ambiguous cell type: ", 100 * nrow(
  cell_categories[cell_category == "ambiguous"]) / nrow(cell_categories), "%")
```

### Compare cell type attributions

```{r cellcat-alluvial, warning=FALSE}
cellcat_cols <- c("cell_category", colnames(colData(sce))[grepl(paste0(
  "CellCat_", methods_sel, collapse = "|"), colnames(colData(sce)))])

cellcat_cols <- cellcat_cols[-grep("Pheno1_fastMNN", cellcat_cols)]

p <- cell_categories[, .(number = .N), by = cellcat_cols] |>
  ggplot(aes(axis1 = get(cellcat_cols[1]),
             axis2 = get(cellcat_cols[2]),
             axis3 = get(cellcat_cols[3]),
             axis4 = get(cellcat_cols[4]),
             # axis5 = get(cellcat_cols[5]),
             y = number)) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  geom_alluvium(aes(fill = get(cellcat_cols[1]))) +
  scale_x_discrete(limits = gsub("cell_category_", "", cellcat_cols)) +
  scale_fill_manual(values = palettes$colors[c(TRUE, FALSE)],
                    name = "Cell category") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if (do_print) { print(p)}

fn <- paste0(paste(today, "CellCat", "alluvial", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

### Number of cells by cell category

```{r cells-per-category}
as_tibble(cell_categories) |>
  select(cell_category) |>
  group_by(cell_category) |>
  add_count(name = "Number of cells") |>
  distinct()
```

## Add celltypes to the main SCE

```{r add-celltypes-sce}
cell_categories <- cell_categories[order(match(cell_categories$cell_id,
                                               colnames(sce))), ]
colData(sce)$cell_category <- cell_categories$cell_category
```



# **Plot cell categories**

## Reduced dimensions

Plot consensus cell categories on reduced dimensions

```{r consensus-dimred}
ccat <- c("immune", "islet", "exocrine", "mesenchymal_endothelial",
          "ambiguous", "other")
names(ccat) <- c("Immune", "Islet", "Exocrine", "Mesenchymal_Endothelial",
                 "Ambiguous", "Other")
palette_ccat <- c(palettes$colors[1:(length(ccat) - 2)], "grey40", "grey")
names(palette_ccat) <- ccat


cur_dat <- scuttle::makePerCellDF(sce[, colnames(sce) %in% metadata(sce)$subset],
                                  use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = metadata(sce)$cases),
         donor_type = factor(donor_type, levels = metadata(sce)$stages)) |>
  arrange(case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, cur_assay, sep = "_")

    p <- plot_dim_red(cur_dat, dimred_name, "cell_category",
                      sample = TRUE, size = 0.1, alpha = 1,
                      palette = palette_ccat)
    if (do_print) print(p)

    fn <- paste0(paste(today, "CellCat", "Consensus", dimred_name,
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
```

## Heatmap

```{r consensus-heatmap}
hmlist <- list()

purrr::map(assay_sel, \(cur_assay) {
  clust_name <- paste("cell_category", cur_assay, sep = "_")

  # Summarize the data
  hm <- summarize_heatmap(sce,
                          expr_values = cur_assay,
                          cluster_by = "cell_category",
                          channels = channels)

  # Display the heatmap
  fn <- paste0(paste(today, "CellCat", "Consensus", cur_assay,
                     "Heatmap", sep = "_"), ".html")

  hmlist[[i]] <- heatmaply(
    heatmaply::normalize(hm), main = clust_name,
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```


## Correlation between channels

```{r cell-category-correlation}
# Define the correlation method
cor_method <- "pearson"

# Function to calculate p values
cor_test_p <- function(x) {
  FUN <- function(x, y) cor.test(x, y, method = cor_method)[["p.value"]]
  z <- outer(
    colnames(x),
    colnames(x),
    Vectorize(function(i, j) FUN(x[, i], x[, j]))
  )
  dimnames(z) <- list(colnames(x), colnames(x))
  z
}

hmlist <- list()
purrr::map2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {

  # Summarize the data
  hm <- summarize_heatmap(sce,
                          expr_values = name_cur_assay,
                          cluster_by = "cell_category",
                          channels = channels)

  # Run the correlation test
  r <- cor(hm, method = cor_method)
  p <- cor_test_p(hm)
  diag(p) <- NA

  # Plot and save the heatmap
  fn <- paste0(paste(today, "CellCat", "Consensus", "Correlation",
                     cur_assay, sep = "_"), ".html")

  hmlist[[i]] <- heatmaply::heatmaply_cor(
    r, node_type = "scatter",
    point_size_mat = -log10(p), point_size_name = "-log10(p-value)",
    label_names = c("x", "y", "Correlation"),
    main = paste("Cell type -", cur_assay),
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```

## Images

Load random images and masks

```{r consensus-viz-load}
nb_images <- 14
image_extension <- ".tiff"

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Select random images and the associated masks
set.seed(seed)
image_list <- list.files(folder_images)
image_list <- mask_list <- sort(sample(unique(image_list), nb_images))
writeLines(c("Selected images:", image_list))

# Load images and masks
images <- yoloader(
  x = sce,
  image_dir = folder_images,
  image_names = image_list,
  type = "stacks"
)

masks <- yoloader(
  x = sce,
  image_dir = folder_masks,
  image_names = mask_list,
  as.is = TRUE,
  type = "masks"
)

if (length(setdiff(mcols(images)$ImageName,
                   mcols(masks)$ImageName)) != 0) {
  print("mcols(images)$ImageName and mcols(masks)$ImageName
        should have the same values")
}

# Subset the SCE object
sce_viz <- sce[, sce$image_fullname %in% image_list]
sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
```

Plot the images

```{r viz-celltype-plot}
fn <- list(filename = file.path(
  plotsave_param$path,
  paste0(paste(today, "CellCat", "Cytomapper", sep = "_"), ".png")))

color_key <- list(c(
  immune = "red", islet = "blue",  exocrine = "yellow",
  mesenchymal_endothelial = "green",
  ambiguous = "white", other = "grey30"))
names(color_key) <- "cell_category"

image_names <- c(unique(colData(sce_viz)[, c("ImageName", "case_id")])$case_id)

cytomapper::plotPixels(images, object = sce_viz, masks,
           cell_id = "cell_number", img_id = "ImageName",
           colour_by = c("SYP", "CD163", "MPO", "CD3e", "PDX1", "CAV1"),
           outline_by = "cell_category",
           # image_title = list(text = image_names),
           colour = color_key,
           bcg = list(SYP = c(0, 5, 1), CD163 = c(0, 5, 1), MPO = c(0, 7, 1),
                      CD3e = c(0, 5, 1), PDX1 = c(0, 3, 1), CAV1 = c(0, 4, 1)),
           image_title = NULL, scale = TRUE, save_plot = fn)
```



# **Save **

## Remove temporary columns

```{r remove-cellcat-columns}
cellcat_cols <- colnames(colData(sce))[grep("CellCat_", colnames(colData(sce)))]
colData(sce)[, cellcat_cols] <- NULL
```

## Convert to SPE

```{r convert-sce-spe}
# Fix sample_id and convert to SPE
sce$sample_id <- sce$image_id
sce <- as(sce, "SpatialExperiment")

# Add the saved metadata, spatial coordinates and colPairs
metadata(sce) <- meta
spatialCoords(sce) <- spatial_coords
colPairs(sce) <- colpairs
```

## Save the updated SPE

Contains cell categories.

```{r save-spe}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
message(assayNames(sce))
message(reducedDimNames(sce))
saveRDS(sce, fn_spe)
```
