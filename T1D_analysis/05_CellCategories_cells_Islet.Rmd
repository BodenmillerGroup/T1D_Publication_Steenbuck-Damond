---
title: "05_ClustersIslet_cells_Islet"
author: "Nicolas Damond, Nathan Steenbuck"
date: "Created: 21 May, 2022; Compiled: `r format(Sys.time(), '%d %b, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
if (rstudioapi::isAvailable()) {
  script_name <- basename(rstudioapi::getSourceEditorContext()$path)
} else {
  script_name <- knitr::current_input()
}

cur_user <- Sys.info()[["user"]]
script_name <- "05_CellCategories_cells_Islet.Rmd"

if (cur_user == "ubuntu") {
    source(file.path("/", "mnt", "central_nas", "projects", 
    "type1_diabetes", "nathan", "T1D_Vol", "T1D_analysis", 
    "analysis", "helpers.R"))
  #n_cores <- future::availableCores() - 1
  n_cores <- 4
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  knitr::opts_knit$set(root_dir = paths$home_data)
} else {
  source(file.path("/", "home", "nsteen", "scripts", "T1D_analysis", "analysis", "helpers.R"))
  n_cores <- 8
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  paths$folder_script <- paths$cluster_folder_script
  paths$folder_in <- paths$cluster_folder_in
  paths$folder_out <- paths$cluster_home 
  knitr::opts_knit$set(root_dir = paths$cluster_home)
}

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("04_QualityControl", paths$object_type, paths$panel_type, sep = "_")
knitr::opts_chunk$set(echo = TRUE)
```



# **Goal**

1. Cluster islet cells using different unsupervised algorithms.
2. For each clustering method, clusters are merged into islet cell types.



# **Settings**  

## Load packages

```{r packages, results='hide'}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(tictoc)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paths$prev, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```



# **Clustering**

Unsupervised clustering is performed by generating a nearest-neighbor graph followed by community detection (using either Louvain or Leiden algorithms).


## Settings

### Load packages

```{r packages2, results="hide"}
suppressPackageStartupMessages(c(
  library(scater),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(ranger),
  library(patchwork),
  library(parallel),
  library(foreach),
  library(doParallel),
  library(BiocParallel)
))
```

## Methods and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno1", "Leiden1")

assay_sel <- c("fastMNN_case_id", "scaled")
names(assay_sel) <- c("exprs", "scaled")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)]))

dimred_sel <- c("UMAP") # , "tSNE")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```

### Select channels to use for clustering

Reduced dimension plots showing marker expression that generated by the previous script can be used to select the most relevant markers for clustering.

```{r select-channels-clustering}
channels_clust <- rownames(rowData(spe)[rowData(spe)$clustering == 1, ])
cat(c("\nChannels used for unsupervised clustering:",
      channels_clust[channels_clust %in% rownames(spe)]))
```


## Split and subset

### Split the dataset

The clustering is performed only on cells located within islets (`sce_isl`). The other cells are stored in a separate object (`sce_exo`).

```{r subset-islet-cells}
# Extract the metadata (to avoid conflicts when merging the SCEs)
meta <- metadata(spe)
spatial_coords <- spatialCoords(spe)
colpairs <- colPairs(spe)

# Split the SPE object (cells outside vs inside islets)
sce_isl <- spe[, spe$distance_to_islet >= 0]
sce_exo <- spe[, !(colnames(spe) %in% colnames(sce_isl))]

# Convert to SingleCellExperiment
sce_isl <- as(sce_isl, "SingleCellExperiment")
sce_exo <- as(sce_exo, "SingleCellExperiment")
remove(spe)
```

### Subset the SPE object

Subset the islet cells for faster processing (`sce_sub`). Cells that were not included are stored in a separate object (`sce_not`).

```{r subset-spe}
if (!("subset_islet" %in% names(meta))) {
  # Cells per case
  nb_cells <- 1000
  
  # Subset the SPE object (nb_cells per case)
  set.seed(seed)
  cell_subset <- as.data.frame(cbind(rn = rownames(colData(sce_isl)),
                                     case_id = colData(sce_isl)$case_id)) |>
    group_by(case_id) |>
    sample_n(nb_cells, replace = TRUE) |>
    pull(rn) |>
    unique()
  
  # Keep the subset cell ids in SPE metadata
  meta[["subset_islet"]] <- sort(as.vector(cell_subset))
}

# Keep only the selected cells and channels
sce_sub <- sce_isl[channels_clust, meta[["subset_islet"]]]
sce_not <- sce_isl[channels_clust, !(colnames(sce_isl) %in% colnames(sce_sub))]
```


## **Clustering: PhenoGraph**

Unsupervised clustering is performed with the [PhenoGraph](https://doi.org/10.1016/j.cell.2015.05.047) algorithm. This method works by generating a nearest-neighbor (kNN) graph of phenotpyic similarities followed by Louvain community dectection. For speed, we run PhenoGraph using the [Rphenoannoy implementation](https://github.com/stuchly/Rphenoannoy).

```{r phenograph-run}
clust_method <- c("Pheno1")

# Number of nearest-neighbors
k <- 30

purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))

  # Run Phenograph
  if (!clust_name %in% colnames(colData(sce_sub))) {
    set.seed(seed)
    ## Try Rphenoannoy. 950 k cells = 17 min!
    tic("Rphenoannoy")
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_sub, cur_assay)), k = k)
    } else {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(reducedDim(sce_sub, cur_assay), k = k)
    }
    toc()

    cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
    colnames(cur_pheno) <- clust_name
    if (cur_assay %in% assayNames(sce_sub)) {
      rownames(cur_pheno) <- colnames(assay(sce_sub, cur_assay))
    } else {
      rownames(cur_pheno) <- rownames(reducedDim(sce_sub, cur_assay))
    }

    # Add Phenograph clusters to the colData of the SCE object
    # Cluster `0` is attributed to non-subsetted cells and not islet cells
    colData(sce_sub)[, clust_name] <<- cur_pheno
    colData(sce_not)[, clust_name] <<- 0
    colData(sce_exo)[, clust_name] <<- 0
    remove(cur_pheno)
  }
})
```


## **Clustering: SNN + Leiden**

Here, we first construct a shared nearest-neighbor graph and identify clusters using the Leiden community detection algorithm.

### Run clustering

```{r SNN-leiden-run}
clust_method <- c("Leiden1")
do_leiden <- FALSE
plot_clustree <- FALSE

# Number of nearest-neighbors for SNN graph
k <- 15

# Resolutions for Leiden algorithm
resolutions <- c(0.000005, 0.0000075, 0.00001, 0.000025,
                  0.00005,  0.000075,  0.0001,  0.00025,
                   0.0005,   0.00075)

# Iterate over selected Assays.
purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))

  if (!clust_name %in% colnames(colData(sce_sub))) {
    do_leiden <- TRUE
    # Build the SNN graph
    set.seed(seed)
    tic("Build Graph")
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        assay.type = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    } else {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        use.dimred = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    }
    toc()
    
    # Leiden clustering. 95 k cells = 3 min. 
    set.seed(seed)
    tic("Leiden Clustering")
    clusters <- furrr::future_map(resolutions, \(cur_resolution) {
      cur_leiden <- igraph::cluster_leiden(
        cur_graph,
        objective_function = "CPM", # could change for additional scalability.
        resolution_parameter = cur_resolution)

      cur_leiden <- cur_leiden$membership
    }, .options = options)
    toc()
    
    # Add clusters to colData(spe)
    for (k in seq_along(resolutions)) {
      res_name <- paste(clust_method, cur_assay, k, sep = "_")
      colData(sce_sub)[, res_name] <<- clusters[[k]]
    }
    
    # Plot cluster tree. This is killed when parallelization is enabled.
    #future::plan(future::sequential)
    p <- clustree::clustree(sce_sub, prefix = paste0(clust_method, "_", cur_assay, "_"))
    print(p)
    # Save.
    fn <- paste0(paste(today, clust_method, cur_assay, "ClusterTree", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param)) 
    remove(cur_graph, clusters)
    #future::plan(future::multicore(workers = n_cores))
  }
})
```

### Optimal cluster resolution

Based on the trees above, select the optimal cluster resolution. Columns corresponding to other resolutions are removed from `colData(spe)`.

```{r SNN-leiden-select}
do_leiden <- TRUE
if (isTRUE(do_leiden)) {
  optimal_res <- c("fastMNN_case_id" = 8, "scaled" = 8)
  
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(clust_method, cur_assay, sep = "_")
    
    optimal_col <- paste(clust_method, cur_assay, optimal_res[cur_assay], sep = "_")
    colData(sce_sub)[, clust_name] <<- colData(sce_sub)[, optimal_col]
    colData(sce_not)[, clust_name] <<- 0
    colData(sce_exo)[, clust_name] <<- 0
    
    other_cols <- colnames(colData(sce_sub))[grep(paste0(clust_name, "_"), colnames(colData(sce_sub)))]
    colData(sce_sub)[, other_cols] <<- NULL
  })
}
gc()
```


## **Train classifier**

Clustering is performed on a cell subset. A random forest classifier is used to attribute clusters to the other cells.

### Random forest

Train a random forest classifier to attribute clusters to cells that were not subsetted.

```{r random-forest-train-predict}
if (isTRUE(do_leiden)) {
  n_features <- length(channels_clust)
    
  purrr::walk(assay_sel, \(cur_assay) {
    purrr::walk(methods_sel, \(cur_method) {
      # cur_assay <- assay_sel[1]; cur_method <- methods_sel[1]
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      print(clust_name)
      
      # Define training (`sce_sub`) and test data (`sce_not`)
      if (cur_assay %in% assayNames(sce_sub)) {
        training_data <- dplyr::bind_cols(t(assay(sce_sub, cur_assay)),
                                          cluster_x = sce_sub[[clust_name]])
        df_data <- t(assay(sce_not, cur_assay))
      } else {
        training_data <- dplyr::bind_cols(reducedDim(sce_sub, cur_assay),
                                          cluster_x = sce_sub[[clust_name]])
        df_data <- reducedDim(sce_not, cur_assay)
      }
      # Changed to dplyr for scalability.
      test_data <- dplyr::bind_cols(df_data, cluster_x = sce_not[[clust_name]])

      # Train
      ranger_model <- ranger(
        formula = cluster_x ~ ., 
        data = training_data,
        mtry = floor(n_features / 3),
        num.trees = 10 * n_features,
        classification = TRUE,
        num.threads = n_cores,
        seed = seed)
      
      # Predict
      rf_predict <- predict(ranger_model, test_data, seed = seed)
      sce_not[[clust_name]] <<- rf_predict$predictions
    })
  })
}
```

### Original vs. predicted

Compare predicted clusters and original clusters on train set (cells on which the clustering algorithms were applied).

```{r random-forest-compare, fig.width=15, fig.height=10}
dat_sub <- scuttle::makePerCellDF(sce_sub, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

dat_not <- scuttle::makePerCellDF(sce_not, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)
dat_not <- dat_not[sample(rownames(dat_not), nrow(dat_sub)), ]

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    dimred_name <- paste("UMAP", cur_assay, sep = "_")
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    
    # Plot all clusters
    p_sub <- plot_dim_red(dat_sub, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Original", sep = " - "))

    p_not <- plot_dim_red(dat_not, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Predicted", sep = " - "))
    
    p <- p_sub + p_not
    print(p)

    fn <- paste0(paste(today, clust_name, "RFcomparison", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
remove(dat_sub, dat_not, p, p_sub, p_not)
```

### Merge test and train datasets

Merge datasets and add clusters to the SPE islet object (`sce_isl`).

```{r random-forest-merge}
# Cluster columns
cluster_cols <- c(outer(methods_sel, assay_sel, FUN = paste, sep = "_"))

# Merge datasets
clusters <- dplyr::bind_rows(as.data.frame(colData(sce_sub)[, cluster_cols]),
                             as.data.frame(colData(sce_not)[, cluster_cols]))
clusters <- clusters[order(match(rownames(clusters), colnames(sce_isl))), ]

# Add to SPE islet object
colData(sce_isl)[, cluster_cols] <- clusters
sce_isl <- as(sce_isl, "SingleCellExperiment")
remove(sce_not)
```


### Save SCE
```{r save-sce}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_isl.rds"))
message(assayNames(sce_isl))
message(reducedDimNames(sce_isl))
saveRDS(sce_isl, fn_spe)

fn_spe_sub <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_sub.rds"))
message(assayNames(sce_sub))
message(reducedDimNames(sce_sub))
saveRDS(sce_sub, fn_spe_sub)

fn_spe_exo <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_exo.rds"))
message(assayNames(sce_exo))
message(reducedDimNames(sce_exo))
saveRDS(sce_exo, fn_spe_exo)

fn_meta <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_meta.rds"))
saveRDS(meta, fn_meta)

fn_spatial_coords <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_spatial_coords.rds"))
saveRDS(spatial_coords, fn_spatial_coords)

fn_colpairs <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_colpairs.rds"))
saveRDS(colpairs, fn_colpairs)
```

# **Visualize clusters**

## Load packages

```{r packages3, results="hide"}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools),
  library(cytomapper)
))
```


## Visualize clusters on reduced dimensions
Reminder: all plots are for the SCE_ISL!
That is, only cells located within islets (logDist >= 0) are shown.

```{r dimred-clusters}
cur_dat <- scuttle::makePerCellDF(sce_isl, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type) |> 
  tibble::as_tibble()

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      
      # Plot all clusters
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      print(p)
      
      fn <- paste0(paste(today, "Clusters_sce_isl", clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
remove(cur_dat, p)
```


## Distribution of marker expression by cluster
```{r violin-clusters-markers, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    print(clust_name)
    sce_isl[[clust_name]] <- as.factor(sce_isl[[clust_name]])
    if (cur_assay %in% assayNames(sce_isl)) {
      cur_dat <- scuttle::makePerCellDF(sce_isl, assay.type = cur_assay,
                                        features = channels_clust, use.dimred = FALSE)
    } else {
      cur_dat <- scuttle::makePerCellDF(sce_isl, assay.type = "scaled", use.dimred = TRUE,
                                        features = channels_clust)
    }

    cur_dat <- melt.data.table(
      as.data.table(cur_dat),
      id.vars = c("image_number", "cell_number", clust_name),
      measure.vars = channels_clust,
      variable.name = "channel",
      value.name = cur_assay
    )
    cur_dat[, MeanExprs := mean(get(cur_assay)),
            by = c("channel", clust_name)]
    
    p <- plot_violin(cur_dat, x = "channel", y = cur_assay,
                     fill_by = "MeanExprs", facet_by = clust_name,
                     title = clust_name) +
      theme(axis.text.x = element_text(size = 8, angle = 90))
    suppressMessages(print(p))
    fn <- paste0(paste(today, "Clusters", clust_name, "Violins",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
}) 
```

## Barplot with cluster frequencies
Visualize the number of cells per cluster. 
```{r viz-cluster-barplot}
cur_dat <- scuttle::makePerCellDF(sce_isl, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type) |> 
  tibble::as_tibble()

purrr::walk(methods_sel, \(cur_method) {
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    title <- paste0("Cluster Abundances: ", clust_name)
    df <- cur_dat |> 
      dplyr::select(all_of(clust_name))  |> 
      dplyr::group_by(across(all_of(clust_name))) |> 
      dplyr::summarise(n = n())

    p <- df |> 
      ggplot2::ggplot(ggplot2::aes(x = factor(get(clust_name)),
                                   y = n, fill = factor(get(clust_name)))) +
      mytheme$standard() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        panel.background = ggplot2::element_rect(colour = "grey20")
      ) + 
      ggplot2::geom_bar(stat = "identity") +
      ggtitle(title) + 
      ggplot2::scale_fill_manual(values = palettes$colors[seq_along(unique(cur_dat[[clust_name]]))]) + 
      xlab("Cluster") +
      ylab("Number of cells")
    print(p)
    fn <- paste0(paste(today, "Clusters", clust_name, "Barplot",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```

## Heatmap of marker expression by cluster
```{r heatmap-clusters-markers}
hmlist <- list()
n <- 1
names(assay_sel) <- c("exprs", "scaled")
purrr::walk(methods_sel, \(cur_method) {
  purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    message(clust_name)
    message(name_cur_assay)
    # Summarize the data

    hm <- summarize_heatmap(sce_isl,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    
    # Display the heatmap
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1
    
    # remove all clusters with less than 10 cells and plot again.
    clust_freq <- table(colData(sce_isl)[[clust_name]])
    keep_clusts <- names(clust_freq)[clust_freq >= 10]
    sce_isl_sub <- sce_isl[, colData(sce_isl)[[clust_name]] %in% keep_clusts]

    hm <- summarize_heatmap(sce_isl_sub,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    # Display the reduced heatmap -> this improves the visualization.
    # Otherwise heatmap is scaled by expression of outliers.
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap_reduced",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1

  })
})
htmltools::tagList(setNames(hmlist, NULL))
names(assay_sel) <- c("exprs",  "scaled")
```


## Visualize clusters with cytomapper

### Select cluster(s) and assay to show

```{r test_test}
assays_clust <- c("Pheno1_scaled", "Pheno1_fastMNN_case_id", 
                  "Leiden1_scaled")#, "Leiden1_fastMNN_case_id")

colData(sce_isl)[, assays_clust] <- 
  colData(sce_isl) |> 
  tibble::as_tibble() |>  
  dplyr::select(all_of(assays_clust)) |>
  dplyr::mutate(dplyr::across(.cols = everything(),
                              .fns = ~ factor(.))) |> 
  as.data.frame()
```

```{r viz-clust-select}
# Leiden-scaled: 
viz_clust <- NULL
viz_method <- "Leiden1"
viz_assay <- "scaled"
```


### Load images and masks

```{r viz-cluster-load}
if (!is.null(viz_clust)) {
  # Define the Channels to view interactively.
  nb_images <- 25
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  
  # Subset the SCE
  sce_viz <- sce_isl[, colData(sce_isl)[[clust_name]] %in% viz_clust]

  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
    min(length(unique(sce_viz$image_fullname)), nb_images)))

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")
  
  # Load images and masks
  images <- yoloader(
    x = sce_viz,
    image_dir = folder_images,
    image_names = image_sub,
    type = "stacks"
  )

  masks <- yoloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )
  
  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
  channels_view <- channels_clust
  sub_images <- cytomapper::getChannels(images, channels_view)
}
```

```{r r-alter-channels}
#channels_view <- c("ProINS", "INS", "Cpep", "ProGCG", "GCG", "SST", "PDX1", "GHRL", "HLA_ABC",
#                   "ARX", "NKX6_1", "AMY", "KRT19", "SYP", "PCSK1", "PCSK2", "IAPP", "CHGA", "NKX2_2", "ECad")

```


### Plot images

Images are saved to disk but not shown.
```{r viz-cluster-plot-interactive}
# Use cytoviewer with images, masks and object
#library(cytoviewer)
#pp <- cytoviewer(image = sub_images, 
#                mask = masks, 
#                object = sce_viz[channels_view, ], 
#                img_id = "ImageName", 
#                cell_id = "cell_number")

##  shiny::runApp(app)
#if (interactive()) {
#}
```

```{r viz-cluster-plot}
if (!is.null(viz_clust)) {
  fn <- list(filename = file.path(
    plotsave_param$path,
    paste0(paste(today, "Cytomapper", clust_name,
                 paste(viz_clust, collapse = "-"), sep = "_"), ".png")))

  cytomapper::plotPixels(images, object = sce_viz, masks,
                         cell_id = "cell_number", img_id = "ImageName",
                         colour_by = c("ProINS", "ProGCG", "SST", "PDX1", "INS", "ARX"),
                         outline_by = c(clust_name),
                         bcg = list(ProINS = c(0, 3, 1), ProGCG = c(0, 5, 1), SST = c(0, 5, 1), 
                                    PDX1 = c(0, 1, 1), INS = c(0, 3, 1), ARX = c(0, 3, 1)),
                         image_title = NULL, scale = TRUE, save_plot = fn)
}
```

### Remove generated files

```{r viz-cluster-remove}
if (!is.null(viz_clust)) {
  remove(sce_viz, images, masks)
}
```

## Plot specific cluster(s)

When many clusters are present, they may not be easy fo visualize on reduced dimension maps. 
Here, a subset of clusters can be selected for plotting.

### Select cluster(s) and assay to show

```{r dimred-cluster-select}
viz_clust <- NULL #c(3, 17, 21) NULL
viz_method <- "Pheno1"
viz_assay <- "scaled"
```

```{r dimred-cluster-plot}
if (!is.null(viz_clust)) {
  # Prepare the data
  cur_dat <- scuttle::makePerCellDF(sce_isl, use.dimred = TRUE) |>
    dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                  donor_type = factor(donor_type, levels = meta$stages)) |>
    dplyr::arrange(case_id, donor_type)
  
  # Clusters and palette
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  clust_nb <-  length(unique(cur_dat[[clust_name]]))
  viz_pal <- palettes$colors[1:clust_nb]
  names(viz_pal) <- 1:clust_nb
  viz_pal[!names(viz_pal) %in% viz_clust] <- "lightgrey"
  
  # Plot
  purrr::walk(dimred_sel, \(cur_dimred) {
  
    dimred_name <- paste(cur_dimred, viz_assay, sep = "_")
    
    p <- plot_dim_red(cur_dat, dimred_name, clust_name, palette = viz_pal,
                      sample = TRUE, size = 0.1, alpha = 1)
    print(p)
    
    # fn <- paste0(
    #   paste(today, paste0("Cluster", paste(viz_clust, collapse = "-")),
    #         clust_name, cur_dimred, sep = "_"), ".png")
    # do.call(ggsave, c(list(fn, p), plotsave_param))
  })
}
```


# **Attribute cell types**

**Note: this section requires manual intervention**  

Here, clusters obtained at the previous steps are manually merged into meaningful cell types. 
Cluster numbers are attributed to the different cell types based on the plots and heatmaps above. 
Consequently, this attribution has to be adapted to the clustering results.  

Cell located outside islets are attributed the cell type `NonIslet` and the cluster `0`.  

## Cell type attribution

Cell type attribution has to be performed once per clustering method and per selected assay.

### Phenograph x scaled counts

```{r celltypes-pheno-scaled}
clust_method <- "Pheno1"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_beta  <- c(5, 6, 7, 8, 13, 16, 25, 26)
#clust_alpha <- c(3, 11, 12, 14, 15, 20, 21, 22, 23, 24)
#clust_delta <- c(10)
#clust_gamma <- c(18)
#clust_epsil <- c(2)
#clust_other <- c(1, 4, 9, 17, 19, 27)
##Â FIrst attribution;
#clust_alpha <- c(3, 12, 14, 15, 17, 18, 19, 20, 21, 24, 26)
#clust_beta <- c(1, 2, 5, 7, 11, 13, 23, 25)
#clust_delta <- c(4)
#clust_gamma <- c(16)
#clust_epsil <- c(8)
#clust_other <- c(6, 9, 10, 22, 27)

## Re-clustering:
clust_beta <- c(1, 2, 6, 10, 12, 15, 24)
clust_alpha <- c(3, 8, 11, 14, 17, 18, 19, 20, 21, 23, 25)
clust_delta <- c(4)
clust_gamma <- c(16)
clust_epsil <- c(7)
clust_other <- c(5, 9, 13, 22)

all_clust <- sort(c(clust_beta, clust_alpha, clust_delta,
                    clust_gamma, clust_epsil, clust_other))

if ((!length(unique(all_clust)) ==
      length(unique(colData(sce_isl)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_beta,
                 paste("CellType", clust_name, sep = "_")] <- "Beta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_alpha,
                 paste("CellType", clust_name, sep = "_")] <- "Alpha"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_delta,
                 paste("CellType", clust_name, sep = "_")] <- "Delta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_gamma,
                 paste("CellType", clust_name, sep = "_")] <- "Gamma"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_epsil,
                 paste("CellType", clust_name, sep = "_")] <- "Epsilon"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"

# Attribute "cell type" for cell not located in islets
colData(sce_exo)[colData(sce_exo)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"
```
### Phenograph x fastMNN counts

```{r celltypes-pheno-fastMNN}
clust_method <- "Pheno1"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

#clust_alpha <- c(2, 3, 4, 8, 14, 15, 19, 21, 22, 23)
#clust_beta <- c(1, 9, 11, 12, 13, 20)
#clust_delta <- c(16, 18)
#clust_gamma <- c(17)
#clust_epsil <- c()
#clust_other <- c(5, 6, 7, 10)
## Re-attribution:.cols
clust_alpha <- c(8, 9, 10, 12, 19, 21, 22, 23, 24, 25, 26, 27)
clust_beta <- c(1, 2, 6, 13, 16, 17, 18, 20)
clust_delta <- c(15)
clust_gamma <- c()
clust_epsil <- c()
clust_other <- c(3, 4, 5, 7, 11, 14)

all_clust <- sort(c(clust_beta, clust_alpha, clust_delta,
                    clust_gamma, clust_epsil, clust_other))

if ((!length(unique(all_clust)) ==
      length(unique(colData(sce_isl)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_beta,
                 paste("CellType", clust_name, sep = "_")] <- "Beta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_alpha,
                 paste("CellType", clust_name, sep = "_")] <- "Alpha"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_delta,
                 paste("CellType", clust_name, sep = "_")] <- "Delta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_gamma,
                 paste("CellType", clust_name, sep = "_")] <- "Gamma"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_epsil,
                 paste("CellType", clust_name, sep = "_")] <- "Epsilon"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"

# Attribute "cell type" for cell not located in islets
colData(sce_exo)[colData(sce_exo)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"
```

### Leiden x scaled counts

```{r celltypes-leiden-scaled}
clust_method <- "Leiden1"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_beta  <- c(11, 12, 13, 14, 16, 26, 31, 32)
#clust_alpha <- c(4, 5, 6, 15, 18, 20, 22, 23, 24, 25, 29, 33, 34)
#clust_delta <- c(9, 21)
#clust_gamma <- c(19)
#clust_epsil <- c(2)
#clust_other <- c(1, 3, 7, 8, 10, 17, 27, 28, 30)
## First clustering:
#clust_alpha <- c(3, 4, 5, 6, 11, 19, 22, 23, 26, 27, 28, 29, 30, 31)
#clust_beta <- c(1, 2, 9, 10, 12, 13,  15, 18, 20, 33)
#clust_gamma <- c(25)
#clust_delta <- c(7, 8)
#clust_epsil <- c(16)
#clust_other <- c(14, 17, 21, 24, 32, 34, 35, 36, 37)
## Re-attribution:
clust_beta <- c(1, 2, 7, 9, 10, 14, 15, 16)
clust_alpha <- c(3, 4, 6, 8, 17, 18, 20, 23, 24, 25, 26, 27, 28, 31, 32, 33) 
clust_delta <- c(5, 29)
clust_epsil <- c(12)
clust_gamma <- c(21)
clust_other <- c(11, 13, 19, 22, 30, 34, 35)

all_clust <- sort(c(clust_beta, clust_alpha, clust_delta,
                    clust_gamma, clust_epsil, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_isl)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_beta,
                 paste("CellType", clust_name, sep = "_")] <- "Beta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_alpha,
                 paste("CellType", clust_name, sep = "_")] <- "Alpha"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_delta,
                 paste("CellType", clust_name, sep = "_")] <- "Delta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_gamma,
                 paste("CellType", clust_name, sep = "_")] <- "Gamma"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_epsil,
                 paste("CellType", clust_name, sep = "_")] <- "Epsilon"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"

# Attribute "cell type" for cell not located in islets
colData(sce_exo)[colData(sce_exo)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"
```

```{r celltypes-leiden-fastmnn}
clust_method <- "Leiden1"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

### First clustering:
clust_other <- c(5, 7, 10, 11, 12, 23)
clust_delta <- c(26, 27)
clust_beta <- c(1, 2, 3, 4, 15, 16, 19, 21, 22, 28)
clust_alpha <- c(6, 8, 9, 13, 14, 17, 18, 20, 24, 25, 29, 30, 31, 32, 33, 34, 35, 36, 37)
clust_epsil <- c()
clust_gamma <- c()

all_clust <- sort(c(clust_beta, clust_alpha, clust_delta,
                    clust_gamma, clust_epsil, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_isl)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_beta,
                 paste("CellType", clust_name, sep = "_")] <- "Beta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_alpha,
                 paste("CellType", clust_name, sep = "_")] <- "Alpha"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_delta,
                 paste("CellType", clust_name, sep = "_")] <- "Delta"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_gamma,
                 paste("CellType", clust_name, sep = "_")] <- "Gamma"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_epsil,
                 paste("CellType", clust_name, sep = "_")] <- "Epsilon"
colData(sce_isl)[colData(sce_isl)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"

# Attribute "cell type" for cell not located in islets
colData(sce_exo)[colData(sce_exo)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "NonIslet"
```

## Visualize attributed cell types

### Plot cell types on reduced dimensions

```{r celltypes-dimred}
# Prepare the data
cur_dat <- scuttle::makePerCellDF(sce_isl, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

# Plot
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste("CellType", cur_method, cur_assay,
                          sep = "_")
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      print(p)
      fn <- paste0(paste(today, clust_name, cur_dimred,
                          sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
remove(cur_dat)
```

### Cell types heatmap

```{r celltypes-heatmap}
hmlist <- list()
n <- 1
names(assay_sel) <- c("exprs", "scaled")
purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste("CellType", cur_method, cur_assay, sep = "_")

    # Summarize the data
    hm <- summarize_heatmap(sce_isl,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    
    # Display the heatmap
    fn <- paste0(paste(today, clust_name, "Heatmap",
                       sep = "_"), ".html")
    
    hmlist[[n]] <- heatmaply::heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
names(assay_sel) <- c("exprs", "scaled")
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize celltypes with cytomapper

Load the masks

```{r viz-celltype-load}
nb_images <- 25
image_extension <- ".tiff"
# clust_name <- paste(viz_method, viz_assay, sep = "_")

set.seed(seed)
image_sub <- sort(sample(
  unique(sce_isl$image_fullname),
  min(length(unique(sce_isl$image_fullname)), nb_images)))

# Subset the SCE to subsampled images
sce_sub <- sce_isl[, sce_isl$image_fullname %in% image_sub]
sce_sub$ImageName <- gsub(image_extension, "", sce_sub$image_fullname)

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Load masks
masks <- yoloader(
  x = sce_sub,
  image_dir = folder_masks,
  image_names = image_sub,
  as.is = TRUE,
  type = "masks"
)
```

Plot the images

```{r viz-celltype-plot}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    if (paste(cur_method, cur_assay, sep = "_") != "Leiden1_fastMNN_case_id") {
      celltype_viz <- paste("CellType", cur_method, cur_assay,
                            sep = "_")
      
      colour_key <- list(c(
        Alpha = palettes$colors[2], Beta = palettes$colors[4],
        Gamma = palettes$colors[6], Delta = palettes$colors[8],
        Epsilon = palettes$colors[3], NonIslet = palettes$colors[12]))
      names(colour_key) <- celltype_viz

      fn <- list(filename = file.path(
        plotsave_param$path,
        paste0(paste(today, "Cytomapper", celltype_viz, sep = "_"), ".png")))

      cytomapper::plotCells(masks, object = sce_sub,
                            cell_id = "cell_number", img_id = "ImageName",
                            colour_by = celltype_viz, colour = colour_key, save_plot = fn)
    }
  })
})
```



# **Merge and save **

## Merge objects

Merge the "islet" and "non-islet" SCE objects, convert to SPE.

```{r merge-spe}
# Merge and re-order
spe <- cbind(sce_isl, sce_exo)
spe <- spe[, order(colData(spe)$case_id,
                   colData(spe)$image_number,
                   colData(spe)$cell_number)]

# Fix sample_id and convert to SPE
spe$sample_id <- spe$image_id
spe <- as(spe, "SpatialExperiment")

# Add the saved metadata, spatial coordinates and colPairs
metadata(spe) <- meta
spatialCoords(spe) <- spatial_coords
colPairs(spe) <- colpairs
```

## Save the updated SCE

Contains islet cell clusters

```{r save-spe}
print(spe)
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
saveRDS(spe, fn_spe)
```
