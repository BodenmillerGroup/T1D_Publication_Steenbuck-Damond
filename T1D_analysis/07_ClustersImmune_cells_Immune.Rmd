---
title: "07_ClustersImmune_cells_Immune"
author: "Nicolas Damond, Nathan Steenbuck"
date: "Created: 01 Sep, 2022; Compiled: `r format(Sys.time(), '%d %b, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
if (rstudioapi::isAvailable()) {
  script_name <- basename(rstudioapi::getSourceEditorContext()$path)
} else {
  script_name <- knitr::current_input()
}

cur_user <- Sys.info()[["user"]]
script_name <- "07_ClustersImmune_cells_Immune.Rmd"

if (cur_user == "ubuntu") {
  source(file.path("/", "mnt", "central_nas", "projects", 
    "type1_diabetes", "nathan", "T1D_Vol", "T1D_analysis", 
    "analysis", "helpers.R"))
  #n_cores <- future::availableCores() - 1
  n_cores <- 4
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  knitr::opts_knit$set(root_dir = paths$home_data)
} else {
  source(file.path("/", "home", "nsteen", "scripts", "T1D_analysis", "analysis", "helpers.R"))
  n_cores <- 8
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  paths$folder_script <- paths$cluster_folder_script
  paths$folder_in <- paths$cluster_folder_in
  paths$folder_out <- paths$cluster_home 
  knitr::opts_knit$set(root_dir = paths$cluster_home)
}

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("06_CellTypesImmune", paths$object_type, paths$panel_type, sep = "_")
knitr::opts_chunk$set(echo = TRUE)
do_print <- FALSE
```


# **Goal**

In scripts 05 to 08, cell types are attributed to all cells in the dataset
in an iterative way:

- `05_CellCategories_cells_Immune`: Attribution of main cell categories 
(immune, islet, exocrine, ...).
- `06_CellTypesImmune_cells_Immune`: Attribution of main cell 
types to immune cells (Lymphocyte, Myeloid, Neutrophil).
- `07_ClustersImmune_cells_Immune` (this script): Further separation of immune cell types 
into clusters.
- `08_CellTypesNonImmune_cells_Immune`: Attribution of cell types
to non-immune cells (Beta, Alpha, Exocrine, ...).
- `08_CellTypesIslet_cells_Immune`: Re-attribution of islet cells
to cell types based on clustering results from the previous step.
- `08_CellTypesIslet_cells_ImmuneII`: Attribution of rare & specific immune cell clusters
like T-reg and T-EMRAs.

In previous scripts, each cell in the dataset was attributed a cell category 
(immune, islet, ...) and a cell type (Lymphocyte, Myeloid, ...).

The goals of this script are *A.* to obtain more specific cell types for 
lymphocytes, and *B-cells* to further divide immune cell types into clusters 
relevant for downstream analysis. 


The following steps are performed in the current script:

- A. Further subdivision of lymphocytes into more precise cell types (i.e., 
`T_CD4`, `T_CD8`, `B`, `NK`, and `Other`).

  + A.1. In the previous script, immune cells were labeled as `Lymphocyte`, 
  `Myeloid` or `Neutrophil`. Here, we select lymphocytes only for more precise
  cell type identification.
  
  + A.2. Dimensionality reduction for visualization purposes. This is performed
  on lymphocytes only.
  
  + A.3. Unsupervised clustering is performed on the `Lymphocyte` object only,
  using the same approach as in the previous scipts: (i) PhenoGraph and ii) 
  Shared-nearest neighbors (SNN) + Leiden community detection) on two different
  count transformations (`exprs` and `scaled`). Only lymphocyte markers are 
  used for clustering.

  + A.4. For each of the four clustering results (two approaches X two count 
  transformations), clusters are manually merged into cell categories based on
  marker expression.
  
  + A.5. Consensus cell categories are attributed by majority vote: if the cell 
  type is the same for three or more of the four approaches, this category is 
  attributed to the cell. If not, the cell is categorized as `ambiguous`.
  Practically, the `Lymphocyte` label in the `colData(spe)$cell_type` column 
  is replaced by more specific labels, e.g., `T_CD4`, `B`, or `NK`.


- B. Attribution of cell clusters. Unlike in previous scripts, where clusters 
were manually merged into known cell types, cluster attribution is here 
performed in a data-driven fashion.
  
  + B.1. As in section A, a list of SCE objects is created, with each
  object containing cells from one immune cell types. This time, lymphocytes 
  are subdivided into the cell types identified in section A.

  + B.2. Unsupervised clustering is performed on each immune cell type, using
  only the markers specific for the cell type at hand. The SNN + Leiden 
  approach is used.
  
  + B.3. Visualize generated clusters with plots and heatmaps.

The resulting clusters are stored in `colData(spe)$cell_cluster_scaled` and
`colData(spe)$cell_cluster_fastMNN`.


# **Settings**  

## Load packages

```{r packages, results='hide'}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(SingleCellExperiment)
))
```

## Paths and settings

```{r settings}
# Paths
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paths$prev, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```

## Methods and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno3", "Leiden3")

assay_sel <- c("fastMNN_case_id", "scaled")
names(assay_sel) <- c("exprs", "scaled")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)]))

dimred_sel <- c("UMAP") # , "tSNE")
writeLines(c("\nReduced dimensions:", dimred_sel))

plot_variables <- c("stages", "cases")
names(plot_variables) <- c("donor_type", "case_id")
writeLines("\nVariables to plot:")
print(plot_variables)

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```



# **A.1. Extract lymphocytes**

Separate SCE objects are generated for each immune cell type and compiled into
a list.


## Define the channels

Define the markers expressed in each cell type.

```{r list-channels}
# Define relevant cell types
celltypes <- c("Lymphocyte", "Myeloid", "Neutrophil")

# Define the channels for each of the cell types
channels_all <- c("LDHA", "TMEM173")

channels <- list()
# we add CD303 (potential pDCs) to lymphocytes, as they often cluster together with B-cells in previous script.
channels[[celltypes[1]]] <- sort(c(
  "CD3e", "CD4", "CD7", "CD8a", "CD20", "FoxP3",
  "HLA_DR", "CD45RA", "CD45RO",
  "CD57", "CD56",
  "GranB", "CD103",
  "CD27", "CD73", "TIM3", "PD1", 
  "CS", "HK1", "ATP5A",
  "CD303", channels_all))
channels[[celltypes[2]]] <- sort(c(
  "CD11b", "CD11c", "CD16", "CD163", "CD204", "CD206",
  "HLA_DR",
  "CD57", "CD56", "CD54", 
  "GranB", 
  "CD27", "CD73", "TIM3", "PD1", 
  "CS", "HK1", "ATP5A", 
  "CD303", "MPO",
  channels_all))
channels[[celltypes[3]]] <- sort(c(
  "Arg1", "MPO", "CD11b", "CD11c", "CD15", "CD66b",   
  "CD54", "CD45RO", 
  channels_all))
                          
print(channels)

# Add the channels to the metadata of the main SPE object
metadata(spe)$channels <- channels
channels_clust <- channels$Lymphocyte
```


## Extract immune cells

The clustering is performed only on immune cells (`sce_imm`).

```{r subset-immune-cells}
# Extract the metadata (to avoid conflicts when merging the SCEs)
meta <- metadata(spe)
spatial_coords <- spatialCoords(spe)
colpairs <- colPairs(spe)

# Subset the SPE (immune cells only)
sce_imm <- spe[, spe$cell_category == "immune"]

# Remove previous reduced dimensions
reducedDims(sce_imm) <- NULL

# Convert to SingleCellExperiment
sce_imm <- as(sce_imm, "SingleCellExperiment")
```


## Subset lymphocytes

```{r subset-lymphocytes}
# Subset the SPE (lymphocytes and lymphocyte markers only)
cur_channels <- metadata(spe)$channels$Lymphocyte
sce_lympho <- sce_imm[cur_channels, sce_imm$cell_type == "Lymphocyte"]

# Remove previous reduced dimensions
reducedDims(sce_lympho) <- NULL

# Add mainExpName
mainExpName(sce_lympho) <- "Lymphocyte"
print(sce_lympho)
```



# **A.2. Dimensionality reduction**

Dimensionality reduction is performed on the lymphocyte SCE object.


## Packages

```{r packages2, results='hide'}
suppressPackageStartupMessages(c(
  library(ggplot2),
  library(uwot),
  library(scuttle),
  library(viridis),
  library(foreach),
  library(doParallel)
))
```


## Run dimensionality reduction

### Run UMAP

```{r run-UMAP}
purrr::walk(assay_sel, \(cur_assay) {
  dimred_name <- paste("UMAP", cur_assay, sep = "_")
  
  if (!dimred_name %in% reducedDimNames(sce_lympho)) {
    cur_umap <- umap(t(assay(sce_lympho, cur_assay)))
    colnames(cur_umap) <- c("UMAP1", "UMAP2")
    rownames(cur_umap) <- colnames(assay(sce_lympho, cur_assay))
    reducedDim(sce_lympho, dimred_name) <<- cur_umap
    remove(cur_umap)
  }
})
```

## Plot reduced dimensions

Because many plots are generated, the functions are run in parallel to save
time. The plots are saved but not displayed in the notebook.

### Plot marker expression

```{r plot-dimred-channels}
purrr::walk(assay_sel, \(cur_assay) {
  cur_dat <- as.data.table(
    scuttle::makePerCellDF(sce_lympho,
                           features = cur_channels,
                           exprs_values = cur_assay))
  
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
    
    if (dimred_name %in% reducedDimNames(sce_lympho)) {
      cur_dat_long <- melt.data.table(
        cur_dat,  measure.vars = cur_channels, variable.name = "channel",
        id.vars = c(paste0(dimred_name, ".1"), paste0(dimred_name, ".2")),
        value.name = cur_assay)
      
      # Plot marker expression
      p <- plot_dim_red_channels(cur_dat_long, dimred_name, cur_assay,
                                 cur_channels)
      fn <- paste0(paste(today, unique(sce_lympho$cell_type)[1], dimred_name, 
                         "Channels", sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param_large))
    }
  })
})
remove(cur_dat, cur_dat_long)
```



# **A.3. Clustering**

At this stage, clustering is only used for cells with a `Lymphocyte` label, as 
it will serve to further subdivide these cells into more specific cell types.

As in the previous scripts, the approach is to generate a nearest-neighbor 
graph followed by community detection (using either Louvain or Leiden 
algorithms).


## Settings

### Load packages

```{r packages3, results='hide'}
suppressPackageStartupMessages(c(
  library(scater),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(BiocParallel)
))
```


## Clustering: PhenoGraph

Unsupervised clustering is performed with the [PhenoGraph](https://doi.org/10.1016/j.cell.2015.05.047) algorithm. This method works by generating a nearest-neighbor (kNN) graph of phenotpyic similarities followed 
by Louvain community dectection. For speed, we run PhenoGraph using the 
[Rphenoannoy implementation](https://github.com/stuchly/Rphenoannoy).

```{r phenograph-run-lympho}
clust_method <- c("Pheno3")
k <- 25

purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))
  
  set.seed(seed)
  cur_pheno_annoy <- Rphenoannoy(t(assay(sce_lympho, cur_assay)), k = k)
  
  cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
  colnames(cur_pheno) <- clust_name
  rownames(cur_pheno) <- colnames(assay(sce_lympho, cur_assay))
  colData(sce_lympho)[, clust_name] <<- cur_pheno
  remove(cur_pheno)
})
```

```{r save-lympho}
fn_spe <- file.path(paths$folder_script, paste0("Lymphocyte_", paths$panel_type, ".rds"))
saveRDS(sce_lympho, fn_spe)
# sce_lympho <- readRDS(fn_spe)
```

## **Clustering: SNN + Leiden**

Here, we first construct a shared nearest-neighbor graph and identify clusters 
using the Leiden community detection algorithm.

### Run clustering

```{r SNN-leiden-run-lympho}
clust_method <- c("Leiden3")
do_leiden <- FALSE
k <- 15

# Resolutions for Leiden algorithm
resolutions <- c(0.000005, 0.0000075, 0.00001, 0.000025,
                  0.00005,  0.000075,  0.0001,  0.00025,
                   0.0005,   0.00075)


purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))
  
  if (!clust_name %in% colnames(colData(sce_lympho))) {
    do_leiden <- TRUE
    
    # Build the SNN graph
    set.seed(seed)
    cur_graph <- scran::buildSNNGraph(sce_lympho,
                                      type = "jaccard",
                                      k = k,
                                      assay.type = cur_assay,
                                      BPPARAM = MulticoreParam(workers = n_cores))
    
    # Leiden clustering
    set.seed(seed)
    clusters <- furrr::future_map(resolutions, \(cur_resolution) {
      cur_leiden <- igraph::cluster_leiden(
        cur_graph,
        objective_function = "CPM",
        resolution_parameter = cur_resolution)
        
        cur_leiden <- cur_leiden$membership
      }, .options = options)

    # Add clusters to colData
    for (k in seq_along(resolutions)) {
      res_name <- paste(clust_method, cur_assay, k, sep = "_")
      colData(sce_lympho)[, res_name] <<- clusters[[k]]
    }
    
    # Plot cluster tree
    p <- clustree::clustree(sce_lympho, prefix = paste0(clust_method, "_", cur_assay, "_"))
    if (do_print) print(p)
    
    fn <- paste0(paste(today, "Lymphocyte", "ClusterTree", clust_method, cur_assay, sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
    remove(cur_graph, clusters)
  }
})
```

### Optimal cluster resolution

Based on the trees above, select the optimal cluster resolution. Columns corresponding to other resolutions are removed from `colData`.

```{r SNN-leiden-select-lympho}
do_leiden <- TRUE
if (isTRUE(do_leiden)) {
  optimal_res <- c("fastMNN_case_id" = 7, "scaled" = 7)

  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(clust_method, cur_assay, sep = "_")

    optimal_col <- paste(clust_method, cur_assay, optimal_res[cur_assay], sep = "_")
    colData(sce_lympho)[, clust_name] <<- colData(sce_lympho)[, optimal_col]

    other_cols <- colnames(colData(sce_lympho))[grep(paste0(clust_name, "_"), colnames(colData(sce_lympho)))]
    colData(sce_lympho)[, other_cols] <<- NULL
  })
}
```

```{r save-lympho2}
fn_spe <- file.path(paths$folder_script, paste0("Lymphocyte_", paths$panel_type, ".rds"))
# saveRDS(sce_lympho, fn_spe)
# sce_lympho <- readRDS(fn_spe)
```

# **Visualize clusters**

## Load packages

```{r packages4, results='hide'}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools),
  library(cytomapper),
  library(ggalluvial)
))
```


## Visualize clusters on reduced dimensions

```{r plot-dimred-lympho-clusters}
cur_dat <- makePerCellDF(sce_lympho, use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = meta$cases),
         donor_type = factor(donor_type, levels = meta$stages)) |>
  arrange(case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      
      # Plot all clusters
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) print(p)
      
      fn <- paste0(paste(today, "Lymphocyte", "Clusters", clust_name,
                          cur_dimred, sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
```


## Distribution of marker expression by cluster

```{r violin-clusters-lympho-markers, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
channels_lympho <- metadata(sce_imm)$channels$Lymphocyte

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    sce_lympho[[clust_name]] <- as.factor(sce_lympho[[clust_name]])
    cur_dat <- scuttle::makePerCellDF(sce_lympho, assay.type = cur_assay,
                                      features = channels_lympho, use.dimred = FALSE)
    
    cur_dat <- melt.data.table(
      as.data.table(cur_dat),
      id.vars = c("image_number", "cell_number", clust_name),
      measure.vars = channels_lympho,
      variable.name = "channel",
      value.name = cur_assay
    )
    cur_dat[, MeanExprs := mean(get(cur_assay)),
            by = c("channel", clust_name)]
    
    p <- plot_violin(cur_dat, x = "channel", y = cur_assay,
                     fill_by = "MeanExprs", facet_by = clust_name,
                     title = clust_name) +
      theme(axis.text.x = element_text(size = 8, angle = 90))
    if (do_print) suppressMessages(print(p))
    fn <- paste0(paste(today, "Lymphocyte", "Clusters", clust_name, "Violins",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```


## Heatmap of marker expression by cluster

```{r heatmap-lympho-clusters-markers}
hmlist <- list()
n <- 1
purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    
    # Summarize the data
    hm <- summarize_heatmap(sce_lympho,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_lympho)
    
    # Display the heatmap
    fn <- paste0(paste(today, "Lymphocyte", "Clusters", clust_name, "Heatmap",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1

    # remove all clusters with less than 10 cells and plot again.
    clust_freq <- table(colData(sce_lympho)[[clust_name]])
    keep_clusts <- names(clust_freq)[clust_freq >= 110]
    sce_isl_sub <- sce_lympho[, colData(sce_lympho)[[clust_name]] %in% keep_clusts]

    hm <- summarize_heatmap(sce_isl_sub,
                            expr_values = cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    # Display the reduced heatmap -> this improves the visualization.
    # Otherwise heatmap is scaled by expression of outliers.
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap_reduced",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

## Barplot with cluster frequencies
Visualize the number of cells per cluster.
```{r viz-cluster-barplot}
cur_dat <- scuttle::makePerCellDF(sce_lympho, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type) |> 
  tibble::as_tibble()

purrr::walk(methods_sel, \(cur_method) {
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    title <- paste0("Cluster Abundances: ", clust_name)
    df <- cur_dat |> 
      dplyr::select(all_of(clust_name))  |> 
      dplyr::group_by(across(all_of(clust_name))) |> 
      dplyr::summarise(n = n())

    p <- df |> 
      ggplot2::ggplot(ggplot2::aes(x = factor(get(clust_name)),
                                   y = n, fill = factor(get(clust_name)))) +
      mytheme$standard() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        panel.background = ggplot2::element_rect(colour = "grey20")
      ) + 
      ggplot2::geom_bar(stat = "identity") +
      ggtitle(title) + 
      ggplot2::scale_fill_manual(values = palettes$colors[seq_along(unique(cur_dat[[clust_name]]))]) + 
      xlab("Cluster") +
      ylab("Number of cells")
    if (do_print) print(p)
    fn <- paste0(paste(today, "Clusters", clust_name, "Barplot",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```


## Metadata per cluster
Cell area, in-outside of islets, and number of cells.

```{r metadata-clusters}
keep_meta <- c("distance_to_islet", "batch", "donor_type", 
               "case_id", "islet_parent")

df <- colData(sce_lympho) |> 
  tibble::as_tibble()  |> 
  dplyr::select(any_of(keep_meta), starts_with("Pheno"), starts_with("Leiden")) 

## Clusters that are inside vs outside. Detect Islet cell clusters!
df |> 
  dplyr::mutate(islet_parent = if_else(islet_parent == 0, "outside", "inside")) |>
  dplyr::group_by(Pheno3_scaled, islet_parent) |> 
  dplyr::summarise(n = n())  |> 
  tidyr::pivot_wider(names_from = islet_parent, values_from = n) |> 
  dplyr::mutate(frac = inside / (inside + outside)) |> 
  dplyr::arrange(desc(frac)) |> 
  print(n = "all")
```


```{r check_enrichment}
df <- as_tibble(colData(sce_lympho)) |> select(case_id, donor_type, image_id, Pheno3_scaled)

df |> 
  dplyr::add_count(Pheno3_scaled) |> 
  dplyr::count(case_id, Pheno3_scaled, n) |> 
  mutate(fraction = nn / n) |> 
  filter(n > 30) |> 
  arrange(desc(fraction)) |> 
  print(n = 30)
```
Donor-specific effects: Cl 22, 20, 21, 2

## Visualize clusters with cytomapper

### Select cluster(s) and assay to show

```{r viz-lympho-clust-select}
# viz_clust <- c(21, 9, 11, 12, 2, 20, 1, 5, 3, 4) #c(3, 17, 21) NULL
all_channels <- rownames(spe)
viz_clust <- NULL # c(22, 21, 9) # c(21, 9, 11, 12, 2, 20, 1, 5, 3, 4)
viz_method <- "Pheno3"
viz_assay <- "scaled"
```

### Load images and masks

```{r viz-lympho-cluster-load}
if (!is.null(viz_clust)) {
  nb_images <- 14
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  
  # Subset the SCE
  sce_viz <- sce_lympho[
    , colData(sce_lympho)[[clust_name]] %in% viz_clust]

  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
    min(length(unique(sce_viz$image_fullname)), nb_images)))
  
  image_sub <- unique(c(image_sub, "6347_Immune_ROI_021.tiff", # "6422_Immune_ROI_039.tiff", 
                "6228_Immune_ROI_029.tiff", "6424_Immune_ROI_064.tiff", 
                "8011_Immune_ROI_017.tiff", "6514_Immune_ROI_005.tiff", "6225_Immune_ROI_053.tiff", "6225_Immune_ROI_043.tiff", "6225_Immune_ROI_057.tiff",
                "6328_Immune_ROI_076.tiff", "6328_Immune_ROI_078.tiff", # "6328_Immune_ROI_001.tiff",
                "6533_Immune_ROI_051.tiff", "6209_Immune_ROI_057.tiff", "6506_Immune_ROI_060.tiff", 
                "6310_Immune_ROI_006.tiff", # "6043_Immune_ROI_014.tiff",  #Â Leiden2: 10
                "6228_Immune_ROI_082.tiff", "6247_Immune_ROI_072.tiff"))

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")
  
  images <- cytomapper::loadImages(file.path(folder_images, image_sub))
  channelNames(images) <- all_channels
  images <- getChannels(images, channels_clust)
  # Add image names to metadata
  mcols(images)$ImageName <- names(images)
  mcols(images)$ImageName <- paste0(mcols(images)$ImageName)

  # Load images and masks
  #images <- yoloader(
  #  x = sce_viz,
  #  image_dir = folder_images,
  #  image_names = image_sub,
  #  type = "stacks"
  #)

  masks <- yoloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )
  
  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
}
```

### Plot images

Images are saved to disk but not shown.

```{r viz-lympho-cluster-plot}
if (!is.null(viz_clust)) {
  fn <- list(filename = file.path(
    plotsave_param$path,
    paste0(paste(today, viz_celltype, "Lymphocyte", "Cytomapper", clust_name,
                 paste(viz_clust, collapse = "-"), sep = "_"), ".png")))

  plotPixels(images, object = sce_viz, masks,
             cell_id = "cell_number", img_id = "ImageName",
             colour_by = c("CD8a", "CD3e", "MPO", "CD163", "CD204", "CD7"),
             outline_by = c(clust_name),
             bcg = list(CD8a = c(0, 5, 1), CD3e = c(0, 5, 1), MPO = c(0, 7, 1),
                        CD163 = c(0, 5, 1), CD204 = c(0, 5, 1), CD7 = c(0, 5, 1)),
             image_title = NULL, scale = TRUE, save_plot = fn)
}
```

### Cytoviewer app.
```{r cytoviewer}
if (!is.null(viz_clust)) {
  library(cytoviewer)
  sce_viz[[clust_name]] <- as.factor(sce_viz[[clust_name]])
  app <- cytoviewer(image = images, 
                    mask = masks, 
                    object = sce_viz,
                    img_id = "ImageName", 
                    cell_id = "cell_number")

  if (interactive()) {
    shiny::runApp(app)
  }
}
```


### Remove generated files

```{r viz-lympho-cluster-remove}
if (!is.null(viz_clust)) {
  remove(sce_viz, images, masks)
}
```

## Plot specific cluster(s)

When many clusters are present, they may not be easy fo visualize on reduced dimension maps. Here, a subset of clusters can be selected for plotting.

### Select cluster(s) and assay to show

```{r dimred-lympho-cluster-select}
#viz_clust <- c(1, 2, 8, 10, 14, 16, 4, 5, 6, 7) #c(3, 17, 21) NULL
viz_clust <- NULL # c(17, 20, 19)
viz_method <- "Leiden3"
viz_assay <- "fastMNN_case_id"
viz_celltype <- "B_others"
```

```{r dimred-lympho-cluster-plot}
if (!is.null(viz_clust)) {
  # Prepare the data
  cur_dat <- makePerCellDF(
    sce_lympho,
    use.dimred = TRUE) |>
    mutate(case_id = factor(case_id, levels = meta$cases),
           donor_type = factor(donor_type, levels = meta$stages)) |>
    arrange(case_id, donor_type)
  
  # Clusters and palette
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  clust_nb <-  length(unique(cur_dat[[clust_name]]))
  viz_pal <- palettes$colors[1:clust_nb]
  names(viz_pal) <- 1:clust_nb
  viz_pal[!names(viz_pal) %in% viz_clust] <- "lightgrey"
  
  # Plot
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, viz_assay, sep = "_")
    
    p <- plot_dim_red(cur_dat, dimred_name, clust_name, palette = viz_pal,
                      sample = TRUE, size = 0.1, alpha = 1)
    if (do_print) print(p)
    
    fn <- paste0(
    paste(today, paste0(viz_celltype, "Lymphocyte", "Cluster", 
                        paste(viz_clust, collapse = "-")),
          clust_name, cur_dimred, sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
}
```



# **A.4. Specify lymphocyte cell types**

**Note: this section requires manual intervention**  

Here, lymphocytes are split into main immune cell types


## Attribute cell types

Cell type attribution has to be performed once per clustering method and per selected assay.

### Phenograph x scaled counts

```{r lympho-pheno-scaled}
clust_method <- "Pheno3"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_CD4  <- c(3, 13, 15)
#clust_CD8 <- c(1, 2, 4, 5, 8, 9, 10, 12, 14, 16, 19)
#clust_B <- c(20)
#clust_NK <- c(6, 11, 17)
#clust_other <- c(7, 18)
clust_CD4 <- c(6, 10, 14, 15)
clust_CD8 <- c(1:5, 9, 11, 12, 20, 21)
clust_B <- c(19)
clust_NK <- c(7, 8)
clust_T_DN <- c(13)
clust_CD303_VIM <- c(16, 17, 18, 23)
clust_other <- c(22)

all_clust <- sort(c(clust_CD4, clust_CD8, clust_B, clust_NK, clust_T_DN, clust_CD303_VIM, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_lympho)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD4,
  paste("CellType", clust_name, sep = "_")] <- "T_CD4"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD8,
  paste("CellType", clust_name, sep = "_")] <- "T_CD8"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_B,
  paste("CellType", clust_name, sep = "_")] <- "B"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_NK,
  paste("CellType", clust_name, sep = "_")] <- "NK"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_other,
  paste("CellType", clust_name, sep = "_")] <- "Other"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_T_DN,
  paste("CellType", clust_name, sep = "_")] <- "T_DN"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD303_VIM,
  paste("CellType", clust_name, sep = "_")] <- "CD303_VIM"
```

### Phenograph x fastMNN counts

```{r lympho-pheno-fastMNN}
clust_method <- "Pheno3"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_CD4  <- c(3, 8, 12, 13, 17)
#clust_CD8 <- c(1, 2, 4, 5, 6, 7, 9, 10, 14)
#clust_B <- c(16)
#clust_NK <- c(11, 15)
#clust_other <- c(18)
clust_CD4 <- c(3, 9, 11, 13, 15)
clust_CD8 <- c(1, 2, 4:8, 10, 14, 16, 21)
clust_B <- c(19)
clust_NK <- c(12)
clust_T_DN <- c(17)
clust_CD303_VIM <- c(18, 20)
clust_other <- c(22)
all_clust <- sort(c(clust_CD4, clust_CD8, clust_B, clust_NK, clust_T_DN, clust_CD303_VIM, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_lympho)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD4,
  paste("CellType", clust_name, sep = "_")] <- "T_CD4"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD8,
  paste("CellType", clust_name, sep = "_")] <- "T_CD8"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_B,
  paste("CellType", clust_name, sep = "_")] <- "B"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_NK,
  paste("CellType", clust_name, sep = "_")] <- "NK"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_other,
  paste("CellType", clust_name, sep = "_")] <- "Other"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_T_DN,
  paste("CellType", clust_name, sep = "_")] <- "T_DN"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD303_VIM,
  paste("CellType", clust_name, sep = "_")] <- "CD303_VIM"
```


### Leiden x scaled counts

```{r lympho-leiden-scaled}
clust_method <- "Leiden3"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_CD4  <- c(9, 16, 18)
#clust_CD8 <- c(1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 13, 15)
#clust_B <- c(17)
#clust_NK <- c(10, 14)
#clust_other <- c(19, 20)
clust_CD4 <- c(7, 8, 13, 18)
clust_CD8 <- c(1:6, 9, 11, 12, 15:17, 21, 23)
clust_NK <- c(10)
clust_T_DN <- c(14)
clust_B <- c(25)
clust_CD303_VIM <- c(19, 27, 24, 20)
clust_other <- c(26, 22, 28)

all_clust <- sort(c(clust_CD4, clust_CD8, clust_B, clust_NK, clust_T_DN, clust_CD303_VIM, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_lympho)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD4,
  paste("CellType", clust_name, sep = "_")] <- "T_CD4"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD8,
  paste("CellType", clust_name, sep = "_")] <- "T_CD8"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_B,
  paste("CellType", clust_name, sep = "_")] <- "B"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_NK,
  paste("CellType", clust_name, sep = "_")] <- "NK"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_other,
  paste("CellType", clust_name, sep = "_")] <- "Other"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_T_DN,
  paste("CellType", clust_name, sep = "_")] <- "T_DN"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD303_VIM,
  paste("CellType", clust_name, sep = "_")] <- "CD303_VIM"
```

### Leiden x fastMNN counts

```{r lympho-leiden-fastMNN}
clust_method <- "Leiden3"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
clust_CD4  <- c(3, 11:13, 16)
clust_CD8 <- c(1, 2, 5:10, 15, 18)
clust_B <- c(19)
clust_NK <- c(14)
clust_T_DN <- c(4)
clust_CD303_VIM <- c(17)
clust_other <- c(20, 21:25)

all_clust <- sort(c(clust_CD4, clust_CD8, clust_B, clust_NK, clust_CD303_VIM, clust_T_DN, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_lympho)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD4,
  paste("CellType", clust_name, sep = "_")] <- "T_CD4"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD8,
  paste("CellType", clust_name, sep = "_")] <- "T_CD8"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_B,
  paste("CellType", clust_name, sep = "_")] <- "B"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_NK,
  paste("CellType", clust_name, sep = "_")] <- "NK"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_other,
  paste("CellType", clust_name, sep = "_")] <- "Other"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_T_DN,
  paste("CellType", clust_name, sep = "_")] <- "T_DN"
colData(sce_lympho)[colData(sce_lympho)[
  , clust_name] %in% clust_CD303_VIM,
  paste("CellType", clust_name, sep = "_")] <- "CD303_VIM"
```


## Visualize attributed cell types

### Plot cell types on reduced dimensions

```{r lympho-palette}
palettes$celltype <- (c(
  T_CD4 = palettes$colors[1], T_CD8 = palettes$colors[2],
  B = palettes$colors[3], NK = palettes$colors[4], CD303_VIM = palettes$colors[5], 
  T_DN = palettes$colors[6], Other = palettes$colors[8]))
```


```{r lympho-dimred}
# Prepare the data
cur_dat <- makePerCellDF(
  sce_lympho,
  use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = meta$cases),
         donor_type = factor(donor_type, levels = meta$stages)) |>
  arrange(case_id, donor_type)

# Plot
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste("CellType", cur_method, cur_assay,
                          sep = "_")
      
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        palette = palettes$celltype,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) print(p)
      
      fn <- paste0(paste(today, "Lymphocyte", clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
```

### Cell types heatmap

```{r lympho-heatmap}
hmlist <- list()
n <- 1
purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, cur_assay_name) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste("CellType", cur_method, cur_assay, sep = "_")

    # Summarize the data
    hm <- summarize_heatmap(sce_lympho,
                            expr_values = cur_assay_name,
                            cluster_by = clust_name,
                            channels = channels_lympho)

    # Display the heatmap
    fn <- paste0(paste(today, clust_name, "Heatmap",
                       sep = "_"), ".html")

    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize celltypes with cytomapper

Load the masks

```{r viz-lympho-celltype-load}
nb_images <- 14
image_extension <- ".tiff"

set.seed(seed)
image_sub <- sort(sample(
  unique(sce_lympho$image_fullname),
  min(length(unique(sce_lympho$image_fullname)), nb_images)))

# Subset the SCE to subsampled images
sce_sub <- sce_lympho[, sce_lympho$image_fullname %in% image_sub]
sce_sub$ImageName <- gsub(image_extension, "", sce_sub$image_fullname)

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Load masks
masks <- yoloader(
  x = sce_sub,
  image_dir = folder_masks,
  image_names = image_sub,
  as.is = TRUE,
  type = "masks"
)
```

Plot the images

```{r viz-lympho-celltype-plot}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    celltype_viz <- paste("CellType", cur_method, cur_assay,
                          sep = "_")

    colour_key <- list(celltype_viz = palettes$celltype)

    fn <- list(filename = file.path(
      plotsave_param$path,
      paste0(paste(today, "Cytomapper", celltype_viz, sep = "_"), ".png")))

    plotCells(masks, object = sce_sub,
              cell_id = "cell_number", img_id = "ImageName",
              colour_by = celltype_viz, colour = colour_key, save_plot = fn)
  })
})
```


# **A.5. Attribute consensus lymphocyte cell types**

Attribute consensus cell types for lymphocytes based on the clustering performed above.

## Cell type concordance

```{r lympho-concordance}
celltype_cols <- colnames(colData(sce_lympho))[grepl(paste0(
  "CellType_", methods_sel, collapse = "|"),
  colnames(colData(sce_lympho)))]

celltypes <- as.data.table(colData(sce_lympho)[
  , c("cell_id", "case_id", "image_number", "cell_number", celltype_cols)])

ct_combination <- t(combn(unique(celltype_cols), 2))

for (i in seq_len(nrow(ct_combination))) {
  cat("\n", ct_combination[i, 1], " vs ", ct_combination[i, 2], "\n")
  
  ct_concord <- nrow(
    celltypes[get(ct_combination[i, 1]) == get(ct_combination[i, 2]), ]
  )
  ct_discord <- nrow(
    celltypes[get(ct_combination[i, 1]) != get(ct_combination[i, 2]), ]
  )
  cat("Number of cells with concordant cell types: ", ct_concord,
      "\nNumber of cells with discordant cell types: ", ct_discord,
      "\nPercentage of cells with concordant cell types:",
      100 * ct_concord / (ct_discord + ct_concord), "%", "\n")
}
```
Pheno3-scaled - Pheno3-fastMNN: 93.5 %
Pheno3-scaled - Leiden3-scaled: 97 %
Pheno3-scaled - Leiden3-fastMNN: 93.6 %
Pheno3-fastMNN- Leiden3-scaled: 94. %
Pheno3-fastMNN - Leiden3-fastMNN: 98.2 %
Leiden3-scaled - Leiden3-fastMNN: 94.1 %

## Attribute consensus cell types

Cells for which 3 out of 4 methods agree on the cell type are attributed this 
cell type, other cells as labeled as "Ambiguous".
FIXME: update.
```{r lympho-consensus-celltype}
column_to_remove <- grep("Pheno3_fastMNN", names(celltypes))

# Remove the column by setting it to NULL
celltypes[, (column_to_remove) := NULL]

# Majority vote
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

celltypes[, cell_type := apply(celltypes, 1, Mode)]
celltypes[, Paste := do.call(paste0, .SD),
          .SDcols = grep("CellType_", colnames(celltypes))]
celltypes[, count := stringr::str_count(Paste, cell_type)]
celltypes[count < 2, cell_type := "Ambiguous"]
celltypes[, `:=`(Paste = NULL, count = NULL)]


cat("Percentage of cells with an ambiguous cell type: ",
    100 * nrow(celltypes[cell_type == "Ambiguous"]) / nrow(celltypes),
    "%")
```

## Compare cell type attributions

```{r lympho-alluvial, warning=FALSE}
celltype_cols <- c("cell_type", colnames(colData(sce_lympho))[
  grepl(paste0("CellType_", methods_sel, collapse = "|"),
        colnames(colData(sce_lympho)))])

celltype_cols <- celltype_cols[-grep("Pheno3_fastMNN", celltype_cols)]

p <- celltypes[, .(number = .N), by = celltype_cols] |>
  ggplot(aes(axis1 = get(celltype_cols[1]),
             axis2 = get(celltype_cols[2]),
             axis3 = get(celltype_cols[3]),
             axis4 = get(celltype_cols[4]),
             # axis5 = get(celltype_cols[5]),
             y = number)) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  geom_alluvium(aes(fill = get(celltype_cols[1]))) +
  scale_x_discrete(limits = gsub("cell_type_", "", celltype_cols)) +
  scale_fill_manual(values = palettes$colors[c(TRUE, FALSE)],
                    name = "Cell Type") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if (do_print) print(p)

fn <- paste0(paste(today, "Lymphocyte", "alluvial", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

### Number of cells by cell type

```{r lympho-cells-per-celltype}
as_tibble(celltypes) |>
  select(cell_type) |>
  group_by(cell_type) |>
  add_count(name = "Number of cells") |>
  distinct()
```

## Add lymphocyte cell types to the immune SCE

```{r add-lympho-celltypes-sce}
celltypes <- celltypes[order(match(
  celltypes$cell_id,
  colnames(sce_imm[, sce_imm$cell_type == "Lymphocyte"]))), ]
sce_imm[, sce_imm$cell_type == "Lymphocyte"]$cell_type <- celltypes$cell_type
```


## Plot consensus cell types

### Run dimensionality reduction

Dimensionality reduction is run on all immune cells ( `sce_imm`).

**UMAP**

```{r run-UMAP2}
purrr::walk(assay_sel, \(cur_assay) {
  dimred_name <- paste("UMAP", cur_assay, sep = "_")
  
  #if (!dimred_name %in% reducedDimNames(sce_imm)) {
    cur_umap <- uwot::umap(t(assay(sce_imm, cur_assay))[, unique(unlist(channels))])
    colnames(cur_umap) <- c("UMAP1", "UMAP2")
    rownames(cur_umap) <- colnames(assay(sce_imm, cur_assay))
    reducedDim(sce_imm, dimred_name) <<- cur_umap
    remove(cur_umap)
  #}
})
```


### Reduced dimensions

Plot consensus cell types on reduced dimensions

```{r consensus-dimred}

palettes$celltype2 <- (c(
  T_CD4 = palettes$colors[1], T_CD8 = palettes$colors[2],
  B = palettes$colors[3], NK = palettes$colors[4],
  Neutrophil = palettes$colors[5], Myeloid = palettes$colors[6],
  T_DN = palettes$colors[7], CD303_VIM = palettes$colors[8]
))

cur_dat <- scuttle::makePerCellDF(sce_imm[, sce_imm$cell_type != "Ambiguous"],
                                  use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = meta$cases),
         donor_type = factor(donor_type, levels = meta$stages)) |>
  arrange(case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, cur_assay, sep = "_")

    p <- plot_dim_red(cur_dat, dimred_name, "cell_type",
                      sample = TRUE, size = 0.1, alpha = 1,
                      palette = palettes$colors) + 
                      labs(title = "", x = "", y = "") + 
                      theme(legend.text = element_text(size = 22),
                            legend.title = element_text(size = 25),
                            legend.position = "right")
    if (do_print) print(p)

    fn <- paste0(paste(today, "CellType", "Consensus", dimred_name,
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})

cur_assay <- "scaled"
cur_dimred <- "UMAP"
dimred_name <- paste(cur_dimred, cur_assay, sep = "_")

p <- plot_dim_red(cur_dat, dimred_name, "cell_type",
                  sample = TRUE, size = 0.1, alpha = 1,
                  palette = palettes$celltype2) + 
                  scale_color_manual(values = palettes$celltype2, breaks = names(palettes$celltype2)) +
                  labs(title = "", x = "", y = "") + 
                  guides(color = guide_legend(title = "Cell Type", override.aes = list(size = 5))) +
                  theme(legend.text = element_text(size = 22),
                        legend.title = element_text(size = 25),
                        legend.position = "right")
if (do_print) print(p)

fn <- paste0(paste(today, "CellType", "Consensus", dimred_name,
                    sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))

fig2b <- p
saveRDS(fig2b, file.path(paths$home_git, "figures", "fig2b.rds"))
```

## Heatmap

```{r consensus-heatmap}
hmlist <- list()
n <- 1
purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste("cell_type", cur_assay, sep = "_")

  # Summarize the data
  hm <- summarize_heatmap(sce_imm[, sce_imm$cell_type != "Ambiguous"],
                          expr_values = cur_assay,
                          cluster_by = "cell_type",
                          channels = unique(unlist(channels)))

  # Display the heatmap
  fn <- paste0(paste(today, "CellType", "Consensus", cur_assay,
                     "Heatmap", sep = "_"), ".html")

  hmlist[[n]] <- heatmaply(
    heatmaply::normalize(hm), main = clust_name,
    file = file.path(paths$folder_script, fn))
  n <- n + 1
})
htmltools::tagList(setNames(hmlist, NULL))

channels <- unique(c(metadata(sce_imm)$channels$Lymphocyte, metadata(sce_imm)$channels$Myeloid), 
                     metadata(sce_imm)$channels$Neutrophil)

cur_assay <- "scaled"
clust_name <- paste("cell_type", cur_assay, sep = "_")

# Summarize the data
hm <- summarize_heatmap(sce_imm[, sce_imm$cell_type != "Ambiguous"],
                        expr_values = cur_assay,
                        cluster_by = "cell_type",
                        channels = channels)
#                        unique(unlist(channels)))

# Counts
ct_anno <- as.data.frame(table(sce_imm[, sce_imm$cell_type!= "Ambiguous"]$cell_type))
rownames(ct_anno) <- ct_anno$Var1
cell_type_counts <- ct_anno$Freq
names(cell_type_counts) <- ct_anno$Var1

breaks <- c(0, 0.5, 0.7, 1)  # Define custom breaks for the color scale
colors <- viridis::viridis(4) 
# Create a color function with more emphasis on the lower values
col_fun <- circlize::colorRamp2(breaks, colors)

saveRDS(hm, file.path(paths$home_git, "figures", "suppfig6a.rds"))
saveRDS(cell_type_counts, file.path(paths$home_git, "figures", "suppfig6a_anno.rds"))

# Create row annotation for cell type counts
row_anno <- ComplexHeatmap::rowAnnotation(
  "Cell Counts" = ComplexHeatmap::anno_barplot(cell_type_counts, 
                         gp = grid::gpar(fill = "skyblue", col = "black"),
                         border = TRUE,
                         width = grid::unit(4, "cm"),
      axis_param = list(gp = grid::gpar(fontsize = 25)),
),       show_annotation_name = FALSE
)
# Display the heatmap
fn <- file.path(paths$folder_script, paste0(paste(today, "CellType", "Consensus", cur_assay,
                    "Heatmap", sep = "_"), ".png"))
png(fn, width = 1200, height = 800)
p <- ComplexHeatmap::Heatmap(heatmaply::normalize(hm), name = "Scaled expression", 
                              col= col_fun,
                              show_row_names = TRUE, show_column_names = TRUE,
                              cluster_rows = TRUE, cluster_columns = TRUE,
                              row_names_gp = grid::gpar(fontsize = 30, fontfamily = "Arial"),
                              column_names_gp = grid::gpar(fontsize = 30, fontfamily = "Arial"), 
                              heatmap_legend_param = list(legend_direction = "horizontal",
                                                          title_position = "topcenter",
                                                          title_gp = grid::gpar(fontsize = 40, fontfamily = "Arial"),
                                                          labels_gp = grid::gpar(fontsize = 40, fontfamily = "Arial")),                             
                            row_dend_gp = grid::gpar(lwd = 3),  # Increase dendrogram line width for rows
                            column_dend_gp = grid::gpar(lwd = 3),  # Increase dendrogram line width for columns
                            row_names_side = "left",
                            row_dend_side = "right") + 
      row_anno


ComplexHeatmap::draw(p, heatmap_legend_side = "top", 
                      padding = unit(c(12, 12, 2, 2), "mm"))   # right and bottom padding

dev.off()
```


## Correlation between channels

```{r cell-category-correlation}
# Define the correlation method
cor_method <- "pearson"

# Function to calculate p values
cor_test_p <- function(x) {
  FUN <- function(x, y) cor.test(x, y, method = cor_method)[["p.value"]]
  z <- outer(
    colnames(x),
    colnames(x),
    Vectorize(function(i, j) FUN(x[, i], x[, j]))
  )
  dimnames(z) <- list(colnames(x), colnames(x))
  z
}
n <- 1
hmlist <- list()
purrr::walk(assay_sel, \(cur_assay) {

  # Summarize the data
  hm <- summarize_heatmap(sce_imm[, sce_imm$cell_type != "Ambiguous"],
                          expr_values = cur_assay,
                          cluster_by = "cell_type",
                          channels = unique(unlist(channels)))

  # Run the correlation test
  r <- cor(hm, method = cor_method)
  p <- cor_test_p(hm)
  diag(p) <- NA

  # Plot and save the heatmap
  fn <- paste0(paste(today, "CellType", "Consensus", "Correlation",
                     cur_assay, sep = "_"), ".html")

  hmlist[[n]] <- heatmaply_cor(
    r, node_type = "scatter",
    point_size_mat = -log10(p), point_size_name = "-log10(p-value)",
    label_names = c("x", "y", "Correlation"),
    main = paste("Cell type -", cur_assay),
    file = file.path(paths$folder_script, fn))
  n <- n + 1
})
htmltools::tagList(setNames(hmlist, NULL))
```

## Images

Load random images and masks

```{r consensus-viz-load}
# nb_images <- 14
# image_extension <- ".tiff"
# 
# # Folders
# folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
# folder_masks <- file.path(paths$folder_in, "masks_cells",
#                           paths$panel_type, "nuclear")
# 
# # Select random images and the associated masks
# set.seed(seed)
# image_list <- list.files(folder_images)
# image_list <- mask_list <- sort(sample(unique(image_list), nb_images))
# writeLines(c("Selected images:", image_list))
# 
# # Load images and masks
# images <- yoloader(
#   x = sce_imm,
#   image_dir = folder_images,
#   image_names = image_list,
#   type = "stacks"
# )
# 
# masks <- yoloader(
#   x = sce_imm,
#   image_dir = folder_masks,
#   image_names = mask_list,
#   as.is=TRUE,
#   bit.depth = ,
#   type = "masks"
# )
# 
# if (length(setdiff(mcols(images)$ImageName,
#                    mcols(masks)$ImageName)) != 0) {
#   print("mcols(images)$ImageName and mcols(masks)$ImageName
#         should have the same values")
# }
# 
# # Subset the SCE object
# sce_viz <- sce[, sce$image_fullname %in% image_list]
# sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
```

Plot the images

```{r viz-celltype-plot}
# fn <- list(filename = file.path(
#   plotsave_param$path,
#   paste0(paste(today, "CellType", "Cytomapper", sep = "_"), ".png")))
# 
# color_key <- list(c(
#   immune = "red", islet = "blue",  exocrine = "yellow",
#   mesenchymal_endothelial = "green",
#   ambiguous = "white", other = "grey30"))
# names(color_key) <- "cell_category"
# 
# image_names <- c(unique(colData(sce_viz)[, c("ImageName", "case_id")])$case_id)
# 
# plotPixels(images, object = sce_viz, masks,
#            cell_id = "cell_number", img_id = "ImageName",
#            colour_by = c("SYP", "CD163", "MPO", "CD3e", "PDX1", "CAV1"),
#            outline_by = "cell_type",
#            # image_title = list(text = image_names),
#            colour = color_key,
#            bcg = list(SYP = c(0, 5, 1), CD163 = c(0, 5, 1), MPO = c(0, 7, 1),
#                       CD3e = c(0, 5, 1), PDX1 = c(0, 3, 1), CAV1 = c(0, 4, 1)),
#            image_title = NULL, scale = TRUE, save_plot = fn)
```

```{r save_sce_imm}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "sce_imm.rds"))
saveRDS(sce_imm, fn_spe)
# sce_imm <- readRDS(fn_spe)
```
# **Define immune cell clusters**

Here, the immune cell types are further divided into clusters, in a data-driven
fashion.

To this aim, a list of SCE objects (one for each immune cell type) is 
generated. Then, unsupervised clustering is applied, using the SNN + Leiden 
approach.


## B.1. Generate a list of cell-type specific SCEs

A list of cell type-specific SCE objects is generated, with each object 
containing cells from one of the immune cell types.

### Define lymphocyte cell types markers

Clustering is applied using only markers specific for the cell type at hand.

```{r list-channels-celltypes}
# Define relevant cell types
celltypes <- c("T_CD4", "T_CD8", "B", "NK", "Myeloid", "Neutrophil", "CD303_VIM", "T_DN")

# Define the channels for lymphocyte cell types
channels_all_lympho <- c("CD45RA", "CD45RO", "CD56", "CD57", 
                         "CD73", "CD27", "PD1", "TIM3",
                         "LDHA", "HK1", "CS", "ATP5A", 
                         "TMEM173")

metadata(spe)$channels$T_CD4 <- sort(c("CD3e", "GranB", "CD4", "FoxP3", 
                                       "CD103", channels_all_lympho))
  
metadata(spe)$channels$T_CD8 <- sort(c("CD3e", "GranB", "CD8a", "FoxP3", 
                                       "CD103", channels_all_lympho))

metadata(spe)$channels$NK <- sort(c("CD3e", "CD7", "GranB", "FoxP3", "CD103", "CD16",
                                    channels_all_lympho))
                 
metadata(spe)$channels$B <- sort(c("HLA_DR", "CD20", channels_all_lympho))

metadata(spe)$channels$T_DN <- sort(c("CD3e", "CD103", channels_all_lympho))

metadata(spe)$channels$CD303_VIM <- sort(c("CD303", "VIM", channels_all_lympho))

# Add the channels to the metadata of the main SPE object
print(metadata(spe)$channels)
```

## Make a list of cell type-specific SCEs

```{r generate-sce-list-celltypes}
sces <- list()

for (h in seq_along(celltypes)) {
  # Subset by channel and cell type
  cur_channels <- metadata(spe)$channels[[celltypes[h]]]
  sces[[h]] <- sce_imm[cur_channels, sce_imm$cell_type == celltypes[h]]
  
  # Remove original reduced dimensions
  reducedDims(sces[[h]]) <- NULL
}
names(sces) <- celltypes
for (i in seq_along(names(sces))) {
  mainExpName(sces[[names(sces[i])]]) <- names(sces)[i]
}
print(sces)
```


## B.2. Clustering

Unsupervised clustering (SNN + Leiden) is applied to each SCE object in the 
`sces` list.
The maximum number of distinct clusters is defined for each cell type.
Then, subclusteirng is run until the minimal number of clusters is reached.

### Clustering: SNN + Leiden

Define the minimal number of clusters to detect per cell type.

```{r min-number-clusters}
min_clusters <- vector(mode = "integer", length = length(celltypes))
names(min_clusters) <- celltypes

min_clusters["T_CD4"] <- 5
min_clusters["T_CD8"] <- 5
min_clusters["B"] <- 2
min_clusters["NK"] <- 3
min_clusters["Myeloid"] <- 8
min_clusters["Neutrophil"] <- 3
min_clusters["CD303_VIM"] <- 2
min_clusters["T_DN"] <- 2

print(min_clusters)
```

### Run clustering

```{r SNN-leiden-run-clusters}
methods_sel <- clust_method <- c("Leiden4")
k <- 15

resolutions <- c(0.000001, 0.0000025, 0.000005, 0.0000075, 0.00001, 0.000025,
                 0.00005,  0.000075,  0.0001,  0.00025,
                 0.0005,   0.00075)

run_leiden <- function(x, exprs_values) {
  purrr::walk(exprs_values, \(cur_assay) {
    clust_name <- paste(clust_method, cur_assay, sep = "_")
    writeLines(c("\n", SingleCellExperiment::mainExpName(x), clust_name))
    
    if (!clust_name %in% colnames(colData(x))) {
      # Build the SNN graph
      set.seed(seed)
      cur_graph <- buildSNNGraph(x,
                                 type = "jaccard",
                                 k = k,
                                 assay.type = cur_assay,
                                 BPPARAM = MulticoreParam(workers = n_cores))
      
      # Leiden clustering
      k <- 1
      clust_number <- 0
      min_cluster_nb <- min_clusters[SingleCellExperiment::mainExpName(x)]
      
      while (clust_number < min_cluster_nb) {
        set.seed(seed)
        cur_leiden <- igraph::cluster_leiden(
          cur_graph,
          objective_function = "CPM",
          resolution_parameter = resolutions[k])
        
        cur_leiden <- cur_leiden$membership
        
        # Remove clusters with less than 10 cells (added to cluster 1)
        cur_leiden[cur_leiden %in% which(table(cur_leiden) < 10)] <- 1
        clust_number <- length(unique(cur_leiden))
        
        cat("Resolution =", resolutions[k],
            "Number of clusters =", clust_number, "\n")
        k <- k + 1
        if (k > length(resolutions))
          break
      }
      
      # Add clusters to colData
      colData(x)[, clust_name] <<- cur_leiden
    }
  })
  return(x)
}

sces <- lapply(sces, run_leiden, assay_sel)
```

### Rename clusters

Each cluster is renamed as a combination of cell type + cluster number.

```{r rename-clusters}
for (h in seq_along(sces)) {
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste("Leiden4", cur_assay, sep = "_")
    final_name <- paste("cell", "cluster", cur_assay, sep = "_") 
    
    sces[[h]][[final_name]] <<- paste(sces[[h]]$cell_type,
                                      sces[[h]][[clust_name]], sep = "_")
  })
}
```

```{r save_sce_clusters}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "sce_clusters.rds"))
saveRDS(sces, fn_spe)
#Â sces <- readRDS(fn_spe)
```

## B.3. Cluster visualization

### Run dimensionality reduction

Run UMAP

```{r run-UMAP-clusters}
# Function to calculate UMAP
calc_umap <- function(x, exprs_values, channels = NULL) {
  if (is.null(channels))
    cur_channels <- rownames(x)
  else
    cur_channels <- channels
  
  purrr::map(exprs_values, \(cur_assay) {
    set.seed(seed)
    dimred_name <- paste("UMAP", cur_assay, sep = "_")
    
    if (!dimred_name %in% reducedDimNames(x)) {
      cur_umap <- umap(t(assay(x, cur_assay)[cur_channels, ]))
      colnames(cur_umap) <- c("UMAP1", "UMAP2")
      rownames(cur_umap) <- colnames(assay(x, cur_assay))
      reducedDim(x, dimred_name) <<- cur_umap
      remove(cur_umap)
    }
  })
  return(x)
}

# Run UMAP
sces <- purrr::map(sces, \(x) {
  calc_umap(x, exprs_values = assay_sel, channels = NULL)
})
# sces <- lapply(sces, FUN = calc_umap, exprs_values = assay_sel)
```

### Visualize clusters on reduced dimensions

For space reasons, the plots are saved to disk but not displayed in this 
notebook.

```{r plot-dimred-clusters}
plot_clusters <- function(x, exprs_values, dimred_sel, methods_sel) {
  cur_dat <- scuttle::makePerCellDF(x, use_dimred = TRUE) |>
    mutate(case_id = factor(case_id, levels = meta$cases),
           donor_type = factor(donor_type, levels = meta$stages)) |>
    arrange(case_id, donor_type)
  
  purrr::map(exprs_values, \(cur_assay) {
    purrr::map(dimred_sel, \(cur_dimred) {
      purrr::map(methods_sel, \(cur_method) {
        dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
        clust_name <- paste("cell_cluster", cur_assay, sep = "_")
        
        p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1)
        fn <- paste0(paste(today, mainExpName(x), clust_name,
                           cur_dimred, sep = "_"), ".png")
        do.call(ggsave, c(list(fn, p), plotsave_param))
      })
    })
  })
}

# Plot
purrr::map(sces, \(x) {
  plot_clusters(x, exprs_values = assay_sel, dimred_sel = dimred_sel, methods_sel = "Leiden4")
})
```

### Plot marker expression

```{r plot-dimred-channels2}
# Function for plotting marker expression on reduced dimensions
lplot_dim_red_channels <- function(x, exprs_values, dimred, channels = NULL) {
  if (is.null(channels))
    cur_channels <- rownames(x)
  else
    cur_channels <- channels
  
  purrr::map(exprs_values, \(cur_assay) {
    cur_dat <- as.data.table(
      makePerCellDF(x,
                    features = cur_channels,
                    exprs_values = cur_assay))
    
    purrr::map(dimred, \(cur_dimred) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      
      if (dimred_name %in% reducedDimNames(x)) {
        cur_dat_long <- melt.data.table(
          cur_dat, measure.vars = cur_channels, variable.name = "channel",
          id.vars = c(paste0(dimred_name, ".1"), paste0(dimred_name, ".2")),
          value.name = cur_assay)
        
        # Plot marker expression
        p <- plot_dim_red_channels(cur_dat_long, dimred_name, cur_assay,
                                   cur_channels, size = 2)
        fn <- paste0(paste(today, unique(x$cell_type)[1], dimred_name, 
                           "Channels", sep = "_"), ".png")
        do.call(ggsave, c(list(fn, p), plotsave_param_large))
      }
    })
  })
}

# Plot
purrr::map(sces, \(x) {
  lplot_dim_red_channels(x, exprs_values = assay_sel, dimred = dimred_sel)
})
```

### Distribution of marker expression by cluster

```{r violin-clusters-markers, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
plot_clusters_violin <- function(x, exprs_values, methods_sel) {
  purrr::map(exprs_values, \(cur_assay) {
    purrr::map(methods_sel, \(cur_method) {
      clust_name <- paste("cell_cluster", cur_assay, sep = "_")
      x[[clust_name]] <- as.factor(x[[clust_name]])
      cur_dat <- makePerCellDF(x, assay.type = cur_assay,
                               features = rownames(x), use.dimred = FALSE)
      
      cur_dat <- melt.data.table(
        as.data.table(cur_dat),
        id.vars = c("image_number", "cell_number", clust_name),
        measure.vars = rownames(x),
        variable.name = "channel",
        value.name = cur_assay
      )
      cur_dat[, MeanExprs := mean(get(cur_assay)),
              by = c("channel", clust_name)]
      
      p <- plot_violin(cur_dat, x = clust_name, y = cur_assay,
                       fill_by = "MeanExprs", facet_by = "channel",
                       title = clust_name) +
        theme(axis.text.x = element_text(size = 8, angle = 90))
      fn <- paste0(paste(today,  mainExpName(x), clust_name, "Violins", 
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param_large))
    })
  })
}

# Plot
purrr::map(sces, \(x) {
  plot_clusters_violin(x, exprs_values = assay_sel, methods_sel)
})
```

### Heatmap of marker expression by cluster

```{r heatmap-clusters-markers, message=FALSE}
plot_clusters_heatmap <- function(x, exprs_values, methods_sel) {
  hmlist <- list()
  n <- 1
  purrr::map(exprs_values, \(cur_assay) {
    purrr::map(methods_sel, \(cur_method) {
      clust_name <- paste("cell_cluster", cur_assay, sep = "_")
      nb_clusters <- length(unique(x[[clust_name]]))
      
      if (nb_clusters > 1) {
        # Summarize the data
        hm <- summarize_heatmap(x,
                                expr_values = cur_assay,
                                cluster_by = clust_name,
                                channels = rownames(x))
        
        # Display the heatmap
        fn <- paste0(paste(today, mainExpName(x), "Clusters", clust_name,
                           "Heatmap", sep = "_"), ".html")
        hmlist[[n]] <-
        heatmaply(
          heatmaply::normalize(hm), main = clust_name,
          file = file.path(paths$folder_script, fn))
        n <- n + 1
      }
    })
  })
  htmltools::tagList(setNames(hmlist, NULL))
}

# Plot
purrr::map(sces, \(x) {
  plot_clusters_heatmap(x, exprs_values = assay_sel, methods_sel)
})
```


## Add immune clusters to the immune SCE

```{r add-cluster-immune-sce}
# Extract ambiguous and "other" cells
sce_ambig <- sce_imm[, sce_imm$cell_type == "Ambiguous"]
sce_other <- sce_imm[, sce_imm$cell_type %in% c("Lympho_Other", "Other")]

sce_ambig$cell_cluster_fastMNN_case_id <- sce_ambig$cell_cluster_scaled <- "Ambiguous"
sce_other$cell_cluster_fastMNN_case_id <- sce_other$cell_cluster_scaled <- "Lympho_Other"

keep_cols <- c("cell_type", "cell_cluster_fastMNN_case_id", "cell_cluster_scaled")

immune_clusters <- rbind(
  colData(sces$T_CD4)[, keep_cols],
  colData(sces$T_CD8)[, keep_cols],
  colData(sces$B)[, keep_cols],
  colData(sces$NK)[, keep_cols],
  colData(sces$Myeloid)[, keep_cols],
  colData(sces$Neutrophil)[, keep_cols],
  colData(sces$CD303_VIM)[, keep_cols],
  colData(sces$T_DN)[, keep_cols],
  colData(sce_other)[, keep_cols],
  colData(sce_ambig)[, keep_cols]
)

immune_clusters <- immune_clusters[order(match(rownames(immune_clusters),
                                               colnames(sce_imm))), ]

sce_imm$cell_type <- immune_clusters$cell_type
sce_imm$cell_cluster_fastMNN_case_id <- immune_clusters$cell_cluster_fastMNN_case_id
sce_imm$cell_cluster_scaled <- immune_clusters$cell_cluster_scaled
```


## Plot consensus immune clusters

### Parameters

```{r cluster-parameters}
# List of clusters and associated color palettes
cluster_cols <- c("cell_cluster_scaled", "cell_cluster_fastMNN_case_id")
names(cluster_cols) <- c("scaled", "fastMNN_case_id")

clusters <- palettes_clust <- vector(mode = "list")
for (i in seq_along(cluster_cols)) {
  clusters[[i]] <- sort(unique(sce_imm[[cluster_cols[i]]]))
  palettes_clust[[i]] <- c(palettes$colors[1:(length(clusters[[i]]))])
}
names(clusters) <- names(palettes_clust) <- cluster_cols
print(c("Immune cell clusters", clusters))
```

### Reduced dimensions

Plot consensus clusters on reduced dimensions

```{r consensus-dimred2}
cur_dat <- scuttle:: makePerCellDF(sce_imm[, sce_imm$cell_type != "Ambiguous"], use_dimred = TRUE) |>
  mutate(case_id = factor(case_id, levels = meta$cases),
         donor_type = factor(donor_type, levels = meta$stages)) |>
  arrange(case_id, donor_type)

for (h in seq_along(cluster_cols)) {
  purrr::walk(assay_sel, \(cur_assay) {
    purrr::walk(dimred_sel, \(cur_dimred) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      set.seed(seed)
      p <- plot_dim_red(cur_dat, dimred_name, cluster_cols[[h]],
                        sample = TRUE, size = 0.1, alpha = 1,
                        palette = palettes_clust[[h]])
      if (do_print) print(p)
      
      fn <- paste0(paste(today, "Cluster", "Consensus", dimred_name,
                         cluster_cols[[h]], sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
}
```

## Heatmap

```{r consensus-heatmap2}
for (h in seq_along(cluster_cols)) {
  
  hmlist <- list()
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(cluster_cols[[h]], cur_assay, sep = "_")
    
    # Summarize the data
    hm <- summarize_heatmap(sce_imm[, sce_imm$cell_type != "Ambiguous"],
                            expr_values = cur_assay,
                            cluster_by = cluster_cols[[h]],
                            channels = rownames(sce_imm))
    
    # Display the heatmap
    fn <- paste0(paste(today, "Cluster", "Consensus", cur_assay,
                       "Heatmap", cluster_cols[[h]], sep = "_"), ".html")
    
    hmlist[[i]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
  })
  htmltools::tagList(setNames(hmlist, NULL))
}
```



# **Finalize and save **

## Merge objects

Add immune clusters to the main SPE

```{r add-immune-clusters-spe}
# Add the new "cell_cluster" columns to the SPE object
spe$cell_cluster_fastMNN_case_id <- "0"
spe$cell_cluster_scaled <- "0"

# Make sure row order is preserved
row_order <- rownames(colData(spe)[spe$cell_category == "immune", ])
sce_imm <- sce_imm[, order(match(colnames(sce_imm), row_order))]

# Add immune cell types and clusters
colData(spe)[row_order, ]$cell_type <- sce_imm$cell_type
colData(spe)[row_order, ]$cell_cluster_fastMNN_case_id <- sce_imm$cell_cluster_fastMNN_case_id
colData(spe)[row_order, ]$cell_cluster_scaled <- sce_imm$cell_cluster_scaled
```


## Save the updated SCE object

Contains all attributed cell types and cell categories

```{r save-spe}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
print(spe)
saveRDS(spe, fn_spe)
```
