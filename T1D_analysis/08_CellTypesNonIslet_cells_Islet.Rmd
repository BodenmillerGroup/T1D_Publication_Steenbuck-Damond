---
title: "08_CellTypesNonIslet_cells_Islet"
author: "Nicolas Damond"
date: "Created: 08 June, 2022; Compiled: `r format(Sys.time(), '%d %b, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
if (rstudioapi::isAvailable()) {
  script_name <- basename(rstudioapi::getSourceEditorContext()$path)
} else {
  script_name <- knitr::current_input()
}

cur_user <- Sys.info()[["user"]]
script_name <- "08_CellTypesNonIslet_cells_Islet.Rmd"

if (cur_user == "ubuntu") {
    source(file.path("/", "mnt", "central_nas", "projects", 
    "type1_diabetes", "nathan", "T1D_Vol", "T1D_analysis", 
    "analysis", "helpers.R"))
  #n_cores <- future::availableCores() - 1
  n_cores <- 4
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  knitr::opts_knit$set(root_dir = paths$home_data)
  do_print <- FALSE
} else {
  source(file.path("/", "home", "nsteen", "scripts", "T1D_analysis", "analysis", "helpers.R"))
  n_cores <- 8
  future::plan(future::multicore(workers = n_cores))
  paths <- getPaths(script_name)
  paths$folder_script <- paths$cluster_folder_script
  paths$folder_in <- paths$cluster_folder_in
  paths$folder_out <- paths$cluster_home 
  knitr::opts_knit$set(root_dir = paths$cluster_home)
  do_print <- TRUE
}

seed <- 123456
set.seed(seed)
options <- furrr::furrr_options(seed = seed)
paths$prev <- paste("06_CellTypesIslet", paths$object_type, paths$panel_type, sep = "_")
options(future.globals.maxSize = 50 * 1024 * 1024 * 1024)
knitr::opts_chunk$set(echo = TRUE)
```


# **Goal**

The goal of this script is to attribute cell types to cells that were not classified as islet cells
in the previous steps (e.g., exocrine, endothelial, or immune cells).

# **Settings**  

## Load packages

```{r packages, results='hide'}
suppressPackageStartupMessages(c(
  library(data.table),
  library(dplyr),
  library(SpatialExperiment),
  library(parallel),
  library(tictoc)
))
```

## Paths and settings

```{r settings}
if (!dir.exists(paths$folder_script)) dir.create(paths$folder_script)
plotsave_param$path <- paths$folder_script
plotsave_param_large$path <- paths$folder_script

# Misc settings
today <- gsub("-", "", Sys.Date())
```

##  Read in the data

Load the SpatialExperiment (SPE) object saved at the previous step.

```{r load-data}
fn_spe <- file.path(paths$folder_out, paths$prev, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
spe <- readRDS(fn_spe)
print(spe)
```



# **Clustering**

Unsupervised clustering is performed by generating a nearest-neighbor graph followed by community detection 
(using either Louvain or Leiden algorithms).


## Settings

### Load packages

```{r packages2, results='hide'}
suppressPackageStartupMessages(c(
  library(scater),
  library(scran),
  library(igraph),
  library(Rphenoannoy),
  library(clustree),
  library(ranger),
  library(patchwork),
  library(parallel),
  library(foreach),
  library(doParallel),
  library(BiocParallel)
))
```

## Methods and assays

Select channels (`channels_clust`), assays (`assay_sel`) and clustering methods (`methods_sel`) to use.

```{r select-methods-assays}
methods_sel <- c("Pheno2", "Leiden2")

assay_sel <- c("fastMNN_case_id", "scaled") #, "harmony_batch")
names(assay_sel) <- c("exprs", "scaled") #, "exprs")
writeLines(c("Assays:", assay_sel[assay_sel %in% assayNames(spe)]))

dimred_sel <- c("UMAP") #, "tSNE")
writeLines(c("\nReduced dimensions:", dimred_sel))

channels <- rownames(spe)[!(grepl("DNA|H3", rownames(spe)))]
cat(c("\nChannels:", channels[channels %in% rownames(spe)]))
cat(c("\nNumber of channels:", length(channels)))
```

### Select the channels for clustering

Here, markers of specific islet cell types are not used for clustering

```{r select-channels-clustering}
channels_clust <- c("HBP", "CFTR", "C3", "CD3", "CD163", "AMY", "KRT19",
                    "PDX1", "FoxA2", "NKX2_2", "CD9", "ADAR", "CAV1", "VIM")
cat(c("\nChannels used for unsupervised clustering:",
      channels_clust[channels_clust %in% rownames(spe)]))
```


## Split and subset

### Split the dataset

The clustering is performed only in cells that were not classified as islet cells (`sce_exo`). The other cells are stored in a separate object (`sce_isl`).

```{r subset-nonislet-cells}
# Extract the metadata (to avoid conflicts when merging the SCEs)
meta <- metadata(spe)
spatial_coords <- spatialCoords(spe)
colpairs <- colPairs(spe)

# Split the SPE (cells outside vs inside islets)
sce_exo <- spe[, spe$cell_category != "islet"]
sce_isl <- spe[, spe$cell_category == "islet"]

# Convert to SingleCellExperiment
sce_exo <- as(sce_exo, "SingleCellExperiment")
sce_isl <- as(sce_isl, "SingleCellExperiment")
remove(spe)
```

### Subset the SPE object

Subset the non-islet cells for faster processing (`sce_sub`). Cells that were not included are stored in a separate object (`sce_not`).

```{r subset-spe}
if (!("subset_exo" %in% names(meta))) {
  # Cells per case
  nb_cells <- 2000
  
  # Subset the SPE object (nb_cells per case)
  set.seed(seed)
  cell_subset <- colData(sce_exo)[, c("cell_id", "case_id")] |>
    tibble::as_tibble() |>
    dplyr::group_by(case_id) |>
    dplyr::sample_n(nb_cells, replace = TRUE) |>
    dplyr::pull(cell_id) |>
    unique()
  
  # Keep the subset cell ids in SPE metadata
  meta[["subset_exo"]] <- sort(as.vector(cell_subset))
}

# Keep only the selected cells and channels
sce_sub <- sce_exo[channels_clust, meta[["subset_exo"]]]
sce_not <- sce_exo[channels_clust, !(colnames(sce_exo) %in% colnames(sce_sub))]
```

```{r save-meta}
fn_meta <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_meta.rds"))
saveRDS(meta, fn_meta)

fn_spatial_coords <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_spatial_coords.rds"))
saveRDS(spatial_coords, fn_spatial_coords)

fn_colpairs <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_colpairs.rds"))
saveRDS(colpairs, fn_colpairs)
```

## **Clustering: PhenoGraph**

Unsupervised clustering is performed with the [PhenoGraph](https://doi.org/10.1016/j.cell.2015.05.047) algorithm. This method works by generating a nearest-neighbor (kNN) graph of phenotpyic similarities followed by Louvain community dectection. For speed, we run PhenoGraph using the [Rphenoannoy implementation](https://github.com/stuchly/Rphenoannoy).

```{r phenograph-run}
clust_method <- c("Pheno2")

# Number of nearest-neighbors
k <- 30

purrr::walk(assay_sel, \(cur_assay) {

  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))

  # Run Phenograph
  if (!clust_name %in% colnames(colData(sce_sub))) {
    set.seed(seed)
    tic("Rphenoannoy")
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(t(assay(sce_sub, cur_assay)), k = k)
    } else {
      cur_pheno_annoy <- Rphenoannoy::Rphenoannoy(reducedDim(sce_sub, cur_assay), k = k)
    }
    toc()

    cur_pheno <- DataFrame(cur_pheno_annoy[[2]]$membership)
    colnames(cur_pheno) <- clust_name
    
    if (cur_assay %in% assayNames(sce_sub)) {
      rownames(cur_pheno) <- colnames(assay(sce_sub, cur_assay))
    } else {
      rownames(cur_pheno) <- rownames(reducedDim(sce_sub, cur_assay))
    }

    # Add Phenograph clusters to the colData of the SCE object
    # Cluster `0` is attributed to non-subsetted cells and not islet cells
    colData(sce_sub)[, clust_name] <<- cur_pheno
    colData(sce_not)[, clust_name] <<- 0
    colData(sce_isl)[, clust_name] <<- 0
    remove(cur_pheno)
  }
})
```


## **Clustering: SNN + Leiden**

Here, we first construct a shared nearest-neighbor graph and identify clusters using the Leiden community detection algorithm.

### Run clustering

```{r SNN-leiden-run}
clust_method <- c("Leiden2")
do_leiden <- FALSE

# Number of nearest-neighbors for SNN graph
k <- 15

# Resolutions for Leiden algorithm
resolutions <- c(0.000005, 0.0000075, 0.00001, 0.000025,
                  0.00005,  0.000075,  0.0001,  0.00025,
                   0.0005,   0.00075)


purrr::walk(assay_sel, \(cur_assay) {
  clust_name <- paste(clust_method, cur_assay, sep = "_")
  writeLines(c("\n", clust_name))
  
  if (!clust_name %in% colnames(colData(sce_sub))) {
    do_leiden <- TRUE
    # Build the SNN graph
    set.seed(seed)
    if (cur_assay %in% assayNames(sce_sub)) {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        assay.type = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    } else {
      cur_graph <- scran::buildSNNGraph(sce_sub,
                                        type = "jaccard",
                                        k = k,
                                        use.dimred = cur_assay,
                                        BPPARAM = BiocParallel::MulticoreParam(workers = n_cores))
    }
    toc()
    
    # Leiden clustering
    set.seed(seed)
    tic("Leiden Clustering")
    clusters <- furrr::future_map(resolutions, \(cur_resolution) {
      cur_leiden <- igraph::cluster_leiden(
        cur_graph,
        objective_function = "CPM", # could change for additional scalability.
        resolution_parameter = cur_resolution)

      cur_leiden <- cur_leiden$membership
    }, .options = options)
    toc()
    
    # Add clusters to colData(spe)
    for (k in seq_along(resolutions)) {
      res_name <- paste(clust_method, cur_assay, k, sep = "_")
      colData(sce_sub)[, res_name] <<- clusters[[k]]
    }
    
    # Plot cluster tree
    p <- clustree::clustree(sce_sub, prefix = paste0(clust_method, "_", cur_assay, "_"))
    print(p)
    # Save.
    fn <- paste0(paste(today, clust_method, cur_assay, "ClusterTree", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param)) 
    remove(cur_graph, clusters)
  }
})
```

### Optimal cluster resolution

Based on the trees above, select the optimal cluster resolution. Columns corresponding to other resolutions are removed from `colData(spe)`.

```{r SNN-leiden-select}
do_leiden <- TRUE
if (isTRUE(do_leiden)) {
  optimal_res <- c("fastMNN_case_id" = 7, "scaled" = 6)
  
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(clust_method, cur_assay, sep = "_")
    
    optimal_col <- paste(clust_method, cur_assay, optimal_res[cur_assay], sep = "_")
    colData(sce_sub)[, clust_name] <<- colData(sce_sub)[, optimal_col]
    colData(sce_not)[, clust_name] <<- 0
    colData(sce_isl)[, clust_name] <<- 0
    
    other_cols <- colnames(colData(sce_sub))[grep(paste0(clust_name, "_"), colnames(colData(sce_sub)))]
    colData(sce_sub)[, other_cols] <<- NULL
  })
}
gc()
```


## **Train classifier**

Clustering is performed on a cell subset. A random forest classifier is used to attribute clusters to the other cells.

### Random forest

Train a random forest classifier to attribute clusters to cells that were not subsetted.

```{r random-forest-train-predict}
tic("RF predict")
if (isTRUE(do_leiden)) {
  n_features <- length(channels_clust)
  
  purrr::walk(assay_sel, \(cur_assay) {
    purrr::walk(methods_sel, \(cur_method) {
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      print(clust_name)
      
      # Define training (`sce_sub`) and test data (`sce_not`)
      if (cur_assay %in% assayNames(sce_sub)) {
        training_data <- dplyr::bind_cols(t(assay(sce_sub, cur_assay)),
                                          cluster = sce_sub[[clust_name]])
        df_data <- t(assay(sce_not, cur_assay))
      } else {
        training_data <- dplyr::bind_cols(reducedDim(sce_sub, cur_assay),
                                          cluster = sce_sub[[clust_name]])
        df_data <- reducedDim(sce_not, cur_assay)
      }
      # Changed to dplyr for scalability.
      test_data <- dplyr::bind_cols(df_data, cluster = sce_not[[clust_name]])

      # Train
      ranger_model <- ranger(
        formula = cluster ~ ., 
        data = training_data,
        mtry = floor(n_features / 3),
        num.trees = 10 * n_features,
        classification = TRUE,
        num.threads = n_cores)
      
      # Predict
      rf_predict <- predict(ranger_model, test_data)
      sce_not[[clust_name]] <<- rf_predict$predictions
    })
  })
  remove(training_data, test_data, ranger_model, rf_predict)
}
toc()
```

### Original vs. predicted

Compare predicted clusters and original clusters on train set (cells on which the clustering algorithms were applied).

```{r random-forest-compare, fig.width=15, fig.height=10}
dat_sub <- scuttle::makePerCellDF(sce_sub, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

dat_not <- scuttle::makePerCellDF(sce_not, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)
dat_not <- dat_not[sample(rownames(dat_not), nrow(dat_sub)), ]

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    dimred_name <- paste("UMAP", cur_assay, sep = "_")
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    
    # Plot all clusters
    p_sub <- plot_dim_red(dat_sub, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Original", sep = " - "))
    
    p_not <- plot_dim_red(dat_not, dimred_name, clust_name,
                          sample = TRUE, size = 0.1, alpha = 1) +
      ggtitle(paste(clust_name, "Predicted", sep = " - "))
    
    p <- p_sub + p_not
    print(p)
    
    fn <- paste0(paste(today, clust_name, "RFcomparison", sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
remove(dat_sub, dat_not, p, p_sub, p_not)
```

### Merge test and train datasets

Merge datasets and add clusters to the SPE object containing non-islet cells (`sce_exo`).

```{r random-forest-merge}
# Cluster columns
cluster_cols <- c(outer(methods_sel, assay_sel, FUN = paste, sep = "_"))

# Merge datasets
clusters <- rbind(colData(sce_sub)[, cluster_cols],
                  colData(sce_not)[, cluster_cols])
clusters <- clusters[order(match(rownames(clusters), colnames(sce_exo))), ]

# Add to SPE islet object
colData(sce_exo)[, cluster_cols] <- clusters
sce_exo <- as(sce_exo, "SingleCellExperiment")
remove(sce_sub, sce_not)
```

```{r save-sce}
fn_spe_exo <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_exo.rds"))
message(assayNames(sce_exo))
message(reducedDimNames(sce_exo))
saveRDS(sce_exo, fn_spe_exo)
# sce_exo <- readRDS(fn_spe_exo)

## Save islet-only object
fn_spe_isl <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_isl.rds"))
saveRDS(sce_isl, fn_spe_isl)
# sce_isl <- readRDS(fn_spe_isl)
```

```{r read-meta}
fn_meta <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_meta.rds"))
meta <- readRDS(fn_meta)

fn_spatial_coords <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_spatial_coords.rds"))
spatial_coords <- readRDS(fn_spatial_coords)

fn_colpairs <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, "_colpairs.rds"))
colpairs <- readRDS(fn_colpairs)
colData(sce_isl)[, "Leiden2_scaled"] <- 0
colData(sce_isl)[, "Pheno2_scaled"] <- 0
colData(sce_isl)[, "Leiden2_fastMNN_case_id"] <- 0
colData(sce_isl)[, "Pheno2_fastMNN_case_id"] <- 0
```

# **Visualize clusters**

## Load packages

```{r packages3, results='hide'}
suppressPackageStartupMessages(c(
  library(heatmaply),
  library(htmltools),
  library(cytomapper),
  library(ggalluvial),
  library(tictoc)
))
```


## Visualize clusters on reduced dimensions

```{r dimred-clusters}
cur_dat <- makePerCellDF(sce_exo, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste(cur_method, cur_assay, sep = "_")
      
      # Plot all clusters
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) {
        print(p)
      }
      
      fn <- paste0(paste(today, "Clusters", clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
remove(cur_dat)
```


## Distribution of marker expression by cluster

```{r violin-clusters-markers, message=FALSE, warning=FALSE, fig.width=15, fig.height=10}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    sce_exo[[clust_name]] <- as.factor(sce_exo[[clust_name]])
    if (cur_assay %in% assayNames(sce_exo)) {
      cur_dat <- scuttle::makePerCellDF(sce_exo, assay.type = cur_assay,
                                        features = channels_clust, use.dimred = FALSE)
    } else {
      cur_dat <- scuttle::makePerCellDF(sce_exo, assay.type = "scaled", use.dimred = TRUE,
                                        features = channels_clust)
    }
    
    cur_dat <- melt.data.table(
      as.data.table(cur_dat),
      id.vars = c("image_number", "cell_number", clust_name),
      measure.vars = channels_clust,
      variable.name = "channel",
      value.name = cur_assay
    )
    cur_dat[, MeanExprs := mean(get(cur_assay)),
            by = c("channel", clust_name)]
    
    p <- plot_violin(cur_dat, x = "channel", y = cur_assay,
                     fill_by = "MeanExprs", facet_by = clust_name,
                     title = clust_name) +
      theme(axis.text.x = element_text(size = 8, angle = 90))
    if (do_print) { 
      suppressMessages(print(p)) 
    }
    fn <- paste0(paste(today, "Clusters", clust_name, "Violins",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```

## Barplot with cluster frequencies
Visualize the number of cells per cluster. 
```{r viz-cluster-barplot}
cur_dat <- scuttle::makePerCellDF(sce_exo, use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type) |> 
  tibble::as_tibble()

purrr::walk(methods_sel, \(cur_method) {
  purrr::walk(assay_sel, \(cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    title <- paste0("Cluster Abundances: ", clust_name)
    df <- cur_dat |> 
      dplyr::select(all_of(clust_name))  |> 
      dplyr::group_by(across(all_of(clust_name))) |> 
      dplyr::summarise(n = n())

    p <- df |> 
      ggplot2::ggplot(ggplot2::aes(x = factor(get(clust_name)),
                                   y = n, fill = factor(get(clust_name)))) +
      mytheme$standard() +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
        panel.background = ggplot2::element_rect(colour = "grey20")
      ) + 
      ggplot2::geom_bar(stat = "identity") +
      ggtitle(title) + 
      ggplot2::scale_fill_manual(values = palettes$colors[seq_along(unique(cur_dat[[clust_name]]))]) + 
      xlab("Cluster") +
      ylab("Number of cells")
    if (do_print) { 
      print(p)
    }
    fn <- paste0(paste(today, "Clusters", clust_name, "Barplot",
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param_large))
  })
})
```

## Heatmap of marker expression by cluster

```{r heatmap-clusters-markers}
hmlist <- list()
n <- 1
names(assay_sel) <- c("counts", "scaled")
purrr::walk(methods_sel, \(cur_method) {
  purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
    clust_name <- paste(cur_method, cur_assay, sep = "_")
    
    # Summarize the data
    hm <- summarize_heatmap(sce_exo,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    
    # Display the heatmap
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  
    # remove all clusters with less than 10 cells and plot again.
    clust_freq <- table(colData(sce_exo)[[clust_name]])
    keep_clusts <- names(clust_freq)[clust_freq >= 10]
    sce_exo_sub <- sce_exo[, colData(sce_exo)[[clust_name]] %in% keep_clusts]

    hm <- summarize_heatmap(sce_exo_sub,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    # Display the reduced heatmap -> this improves the visualization.
    # Otherwise heatmap is scaled by expression of outliers.
    fn <- paste0(paste(today, "Clusters", clust_name, "Heatmap_reduced",
                       sep = "_"), ".html")
    hmlist[[n]] <- heatmaply(
       heatmaply::normalize(hm), main = clust_name, 
       file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
names(assay_sel) <- c("exprs", "scaled")
```


## Visualize clusters with cytomapper

### Select cluster(s) and assay to show

```{r viz-clust-select}
#viz_clust <- c(1, 2, 3, 4, 5, 18) # all ductal
viz_clust <- NULL
viz_method <- "Leiden2"
viz_assay <- "scaled"
```

### Load images and masks

```{r viz-cluster-load}
if (!is.null(viz_clust)) {
  #nb_images <- 14
  nb_images <- 30
  image_extension <- ".tiff"
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  
  # Subset the SCE
  sce_viz <- sce_exo[, colData(sce_exo)[[clust_name]] %in% viz_clust]
  sce_viz$Pheno2_fastMNN_case_id <- factor(sce_viz$Pheno2_fastMNN_case_id, levels = unique(sce_exo$Pheno2_fastMNN_case_id))

  set.seed(seed)
  image_sub <- sort(sample(
    unique(sce_viz$image_fullname),
    min(length(unique(sce_viz$image_fullname)), nb_images)))

  # Folders
  folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
  folder_masks <- file.path(paths$folder_in, "masks_cells",
                            paths$panel_type, "whole-cell")
  
  # Load images and masks
  images <- yoloader(
    x = sce_viz,
    image_dir = folder_images,
    image_names = image_sub,
    type = "stacks"
  )

  masks <- yoloader(
    x = sce_viz,
    image_dir = folder_masks,
    image_names = image_sub,
    as.is = TRUE,
    type = "masks"
  )
  
  sce_viz <- sce_viz[, sce_viz$image_fullname %in% image_sub]
  sce_viz$ImageName <- gsub(image_extension, "", sce_viz$image_fullname)
}
```

### Cytoviewer:
```{r viz-cluster-cytoviewer}
#if (!is.null(viz_clust)) {
#  channels_view <- channels_clust
#  sub_images <- cytomapper::getChannels(images, channels_view)
#  library(cytoviewer)
#  app <- cytoviewer(image = sub_images, 
#                    mask = masks, 
#                    object = sce_viz[channels_view, ], 
#                    img_id = "ImageName", 
#                    cell_id = "cell_number")#
#
#  if (interactive()) {
#    shiny::runApp(app)
#  }
#}
```

### Plot images

Images are saved to disk but not shown.

```{r viz-cluster-plot}
if (!is.null(viz_clust)) {
  fn <- list(filename = file.path(
    plotsave_param$path,
    paste0(paste(today, "Cytomapper", clust_name,
                 paste(viz_clust, collapse = "-"), sep = "_"), ".png")))

  plotPixels(images, object = sce_viz, masks,
             cell_id = "cell_number", img_id = "ImageName",
             colour_by = c("KRT19", "VIM", "PDX1", "CAV1", "CHGA", "CD163"),
             outline_by = c(clust_name),
             bcg = list(KRT19 = c(0, 5, 1), VIM = c(0, 5, 1), PDX1 = c(0, 5, 1),
                        CAV1 = c(0, 5, 1), CHGA = c(0, 5, 1), CD163 = c(0, 5, 1)),
             image_title = NULL, scale = TRUE, save_plot = fn)
}
```


### Remove generated files

```{r viz-cluster-remove}
if (!is.null(viz_clust)) {
  remove(sce_viz, images, masks)
}
```


## Plot specific cluster(s)

When many clusters are present, they may not be easy fo visualize on reduced dimension maps. 
Here, a subset of clusters can be selected for plotting.

### Select cluster(s) and assay to show

```{r dimred-cluster-select-fastMNN}
#viz_clust <- c(19, 24, 26, 27, 20, 25, 21, 28, 29, 32) # islet-like, Fibro, Endo, Immune
#viz_clust <- c(10, 5, 7, 12, 37, 17, 15, 16, 2, 34, 30, 18, 33, 23, 29, 32, 13, 11, 31, 8) # acinar
# viz_clust <- c(1, 3, 4, 35, 36, 22, 14, 9, 6) # ductal
viz_clust <- NULL
viz_method <- "Leiden2"
viz_assay <- "fastMNN_case_id"
```

```{r dimred-cluster-load}
if (!is.null(viz_clust)) {
  # Prepare the data
  cur_dat <- scuttle::makePerCellDF(
    sce_exo[, colnames(sce_exo) %in% meta[["subset_exo"]]],
    use.dimred = TRUE) |>
    dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                  donor_type = factor(donor_type, levels = meta$stages)) |>
    dplyr::arrange(case_id, donor_type)
}
```

```{r dimred-cluster-plot}
if (!is.null(viz_clust)) {
  # Clusters and palette
  clust_name <- paste(viz_method, viz_assay, sep = "_")
  clust_nb <-  length(unique(cur_dat[[clust_name]]))
  viz_pal <- palettes$colors[1:clust_nb]
  names(viz_pal) <- 1:clust_nb
  viz_pal[!names(viz_pal) %in% viz_clust] <- "lightgrey"
  
  # Plot
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, viz_assay, sep = "_")
    
    p <- plot_dim_red(cur_dat, dimred_name, clust_name, palette = viz_pal,
                      sample = TRUE, size = 0.1, alpha = 1)
    if (do_print){ print(p)}
    
    fn <- paste0(
       paste(today, paste0("Cluster", paste(viz_clust, collapse = "-")),
             clust_name, cur_dimred, sep = "_"), ".png")
     do.call(ggsave, c(list(fn, p), plotsave_param))
  })
}
```



# **Attribute cell types**

**Note: this section requires manual intervention**  

Here, clusters obtained at the previous steps are manually merged into meaningful cell types. 
Cluster numbers are attributed to the different cell types based on the plots and heatmaps above. 
Consequently, this attribution has to be adapted to the clustering results.  

Cell located outside islets are attributed the cell type `NonIslet` and the cluster `0`.  

## Cell type attribution

Cell type attribution has to be performed once per clustering method and per selected assay.

### Phenograph x scaled counts

```{r celltypes-pheno-scaled}
clust_method <- "Pheno2"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_acinar  <- c(1, 4, 5, 8, 12, 14, 15, 17, 19, 23)
##clust_endoth <- c(7)
#clust_ductal <- c(2, 3, 6, 18, 20)
#clust_fibro <- c(11)
#clust_tcell <- c(10)
#clust_isletlike <- c(9)
#clust_macro <- c(22)
#clust_other <- c(13, 16, 21)
clust_acinar  <- c(2, 3, 7, 8, 9, 12, 15, 19, 20, 21)
clust_endoth <- c(4, 18)
clust_ductal <- c(1, 10, 11, 13)
clust_fibro <- c(5)
clust_tcell <- c(16)
clust_isletlike <- c(6)
clust_macro <- c(14)
clust_other <- c(17)
# 17, 5 unclear.


all_clust <- sort(c(clust_acinar, clust_ductal, clust_endoth, clust_fibro,
                    clust_isletlike, clust_tcell, clust_macro, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_exo)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_acinar,
                 paste("CellType", clust_name, sep = "_")] <- "Acinar"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_ductal,
                 paste("CellType", clust_name, sep = "_")] <- "Ductal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_endoth,
                 paste("CellType", clust_name, sep = "_")] <- "Endothelial"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_fibro,
                 paste("CellType", clust_name, sep = "_")] <- "Mesenchymal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_isletlike,
                 paste("CellType", clust_name, sep = "_")] <- "IsletLike"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_tcell,
                 paste("CellType", clust_name, sep = "_")] <- "Tcell"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_macro,
                 paste("CellType", clust_name, sep = "_")] <- "Macrophage"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "Other"

# Attribute "cell type" for cells located in islets
colData(sce_isl)[colData(sce_isl)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "Islet"
```

### Phenograph x fastMNN_case_id counts

```{r celltypes-pheno-fastMNN_case_id}
clust_method <- "Pheno2"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_acinar  <- c(1, 4, 5, 7, 11, 14, 16, 20)
#clust_ductal <- c(2, 3, 8, 9, 10, 13)
#clust_endoth <- c(15)
#clust_fibro <- c(18)
#clust_isletlike <- c(6)
#clust_tcell <- c(19)
#clust_macro <- c(12)
#clust_other <- c(17) 
clust_acinar  <- c(4, 5, 6, 8, 10, 11, 12, 15, 17, 18, 19, 20, 21, 24, 26, 27)
clust_ductal <- c(1, 2, 3, 9, 16, 22, 23, 25)
clust_endoth <- c(7, 28)
clust_fibro <- c(14)
clust_isletlike <- c()
clust_tcell <- c()
clust_macro <- c(13)
clust_other <- c()

all_clust <- sort(c(clust_acinar, clust_ductal, clust_endoth, clust_fibro,
                    clust_isletlike, clust_tcell, clust_macro, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_exo)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_acinar,
                 paste("CellType", clust_name, sep = "_")] <- "Acinar"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_ductal,
                 paste("CellType", clust_name, sep = "_")] <- "Ductal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_endoth,
                 paste("CellType", clust_name, sep = "_")] <- "Endothelial"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_fibro,
                 paste("CellType", clust_name, sep = "_")] <- "Mesenchymal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_isletlike,
                 paste("CellType", clust_name, sep = "_")] <- "IsletLike"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_tcell,
                 paste("CellType", clust_name, sep = "_")] <- "Tcell"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_macro,
                 paste("CellType", clust_name, sep = "_")] <- "Macrophage"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "Other"

# Attribute "cell type" for cells located in islets
colData(sce_isl)[colData(sce_isl)[, clust_name] == 0,
             paste("CellType", clust_name, sep = "_")] <- "Islet"
```

### Leiden x scaled counts

```{r celltypes-leiden-scaled}
clust_method <- "Leiden2"
clust_assay <- "scaled"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_acinar  <- c(1, 2, 3, 4, 6, 10, 16, 17, 18, 23, 25)
#clust_ductal <- c(5, 7, 11, 12, 13, 26)
#clust_endoth <- c(9, 14)
#clust_fibro <- c(19)
#clust_isletlike <- c(15)
#clust_tcell <- c(22)
#clust_macro <- c(21, 24)
#clust_other <- c(8, 20)
clust_acinar  <- c(6, 7, 8, 9, 10, 11, 13, 21, 22, 23, 25)
clust_ductal <- c(1, 2,  3, 4, 5, 18)
clust_endoth <- c(14, 24)
clust_fibro <- c(20, 15)
clust_isletlike <- c(16)
clust_tcell <- c(19)
clust_macro <- c(17)
clust_other <- c(12)

all_clust <- sort(c(clust_acinar, clust_ductal, clust_endoth, clust_fibro,
                    clust_isletlike, clust_tcell, clust_macro, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_exo)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_acinar,
                 paste("CellType", clust_name, sep = "_")] <- "Acinar"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_ductal,
                 paste("CellType", clust_name, sep = "_")] <- "Ductal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_endoth,
                 paste("CellType", clust_name, sep = "_")] <- "Endothelial"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_fibro,
                 paste("CellType", clust_name, sep = "_")] <- "Mesenchymal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_isletlike,
                 paste("CellType", clust_name, sep = "_")] <- "IsletLike"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_tcell,
                 paste("CellType", clust_name, sep = "_")] <- "Tcell"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_macro,
                 paste("CellType", clust_name, sep = "_")] <- "Macrophage"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "Other"

# Attribute "cell type" for cells located in islets
colData(sce_isl)[colData(sce_isl)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "Islet"
```

### Leiden x fastMNN_case_id counts

```{r celltypes-leiden-fastMNN_case_id}
clust_method <- "Leiden2"
clust_assay <- "fastMNN_case_id"

if (!clust_assay %in% assay_sel)
  stop("The selected assay is not in the assays selected for clustering")

clust_name <- paste(clust_method, clust_assay, sep = "_")
print(clust_name)

# Define which clusters correspond to which cell types
#clust_acinar  <- c(1, 2, 3, 6, 7, 13, 14, 18)
#clust_ductal <- c(4, 5, 9, 11, 12)
#clust_endoth <- c(16)
#clust_fibro <- c(17)
#clust_isletlike <- c(8, 19)
#clust_tcell <- c(15)
#clust_macro <- c(10)
#clust_other <- c()
clust_acinar  <- c(2, 5, 7, 8, 10, 11, 12, 13, 15, 16, 17, 18, 23, 30, 31, 33, 34, 37)
clust_ductal <- c(1, 3, 4, 6, 9, 14, 22, 35, 36)
clust_endoth <- c(20, 27)
clust_fibro <- c(25)
clust_isletlike <- c()
clust_tcell <- c(26)
clust_macro <- c(19, 24)
clust_other <- c(21, 28, 29, 32)


all_clust <- sort(c(clust_acinar, clust_ductal, clust_endoth, clust_fibro,
                    clust_isletlike, clust_tcell, clust_macro, clust_other))

if ((!length(unique(all_clust)) ==
     length(unique(colData(sce_exo)[, clust_name]))) ||
    any(duplicated(all_clust))) {
  stop("Recheck cluster attribution")
}

# Add cell types to the SCE object
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_acinar,
                 paste("CellType", clust_name, sep = "_")] <- "Acinar"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_ductal,
                 paste("CellType", clust_name, sep = "_")] <- "Ductal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_endoth,
                 paste("CellType", clust_name, sep = "_")] <- "Endothelial"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_fibro,
                 paste("CellType", clust_name, sep = "_")] <- "Mesenchymal"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_isletlike,
                 paste("CellType", clust_name, sep = "_")] <- "IsletLike"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_tcell,
                 paste("CellType", clust_name, sep = "_")] <- "Tcell"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_macro,
                 paste("CellType", clust_name, sep = "_")] <- "Macrophage"
colData(sce_exo)[colData(sce_exo)[, clust_name] %in% clust_other,
                 paste("CellType", clust_name, sep = "_")] <- "Other"

# Attribute "cell type" for cells located in islets
colData(sce_isl)[colData(sce_isl)[, clust_name] == 0,
                 paste("CellType", clust_name, sep = "_")] <- "Islet"
```


## Visualize attributed cell types

### Plot cell types on reduced dimensions

```{r palette$celltypes}
palettes$celltype <- (c(
  Acinar = palettes$colors[1], Ductal = palettes$colors[2],
  Endothelial = palettes$colors[3], Mesenchymal = palettes$colors[4],
  IsletLike = palettes$colors[5], Tcell = palettes$colors[6],
  Macrophage = palettes$colors[7], Other = palettes$colors[8]))
```


```{r celltypes-dimred}
# Prepare the data
cur_dat <- scuttle::makePerCellDF(
  sce_exo[, colnames(sce_exo) %in% meta[["subset_exo"]]],
  use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
         donor_type = factor(donor_type, levels = meta$stages)) |>
  dplyr::arrange(case_id, donor_type)

# Plot
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    purrr::walk(methods_sel, \(cur_method) {
      dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
      clust_name <- paste("CellType", cur_method, cur_assay,
                          sep = "_")
      
      p <- plot_dim_red(cur_dat, dimred_name, clust_name,
                        palette = palettes$celltype,
                        sample = TRUE, size = 0.1, alpha = 1)
      if (do_print) {
        print(p) 
      }
      
      fn <- paste0(paste(today, clust_name, cur_dimred,
                         sep = "_"), ".png")
      do.call(ggsave, c(list(fn, p), plotsave_param))
    })
  })
})
remove(cur_dat) 
```

### Cell types heatmap

```{r celltypes-heatmap}
hmlist <- list()
n <- 1

purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    clust_name <- paste("CellType", cur_method, cur_assay,
                        sep = "_")
  
    # Summarize the data
    hm <- summarize_heatmap(sce_exo,
                            expr_values = name_cur_assay,
                            cluster_by = clust_name,
                            channels = channels_clust)
    
    # Display the heatmap
    fn <- paste0(paste(today, clust_name, "Heatmap",
                       sep = "_"), ".html")
    
    hmlist[[n]] <- heatmaply(
      heatmaply::normalize(hm), main = clust_name,
      file = file.path(paths$folder_script, fn))
    n <- n + 1
  })
})
htmltools::tagList(setNames(hmlist, NULL))
```

### Visualize celltypes with cytomapper

Load the masks

```{r viz-celltype-load}
nb_images <- 25
image_extension <- ".tiff"

set.seed(seed)
image_sub <- sort(sample(
  unique(sce_isl$image_fullname),
  min(length(unique(sce_isl$image_fullname)), nb_images)))

# Subset the SCE to subsampled images
sce_sub <- sce_exo[, sce_exo$image_fullname %in% image_sub]
sce_sub$ImageName <- gsub(image_extension, "", sce_sub$image_fullname)

# Folders
folder_images <- file.path(paths$folder_in, "img", paths$panel_type)
folder_masks <- file.path(paths$folder_in, "masks_cells",
                          paths$panel_type, "whole-cell")

# Load masks
masks <- yoloader(
  x = sce_sub,
  image_dir = folder_masks,
  image_names = image_sub,
  as.is = TRUE,
  type = "masks"
)
```

Plot the images

```{r viz-celltype-plot}
purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(methods_sel, \(cur_method) {
    celltype_viz <- paste("CellType", cur_method, cur_assay,
                          sep = "_")
    
    colour_key <- list(celltype_viz = palettes$celltype)

    fn <- list(filename = file.path(
      plotsave_param$path,
      paste0(paste(today, "Cytomapper", celltype_viz, sep = "_"), ".png")))

    plotCells(masks, object = sce_sub,
              cell_id = "cell_number", img_id = "ImageName",
              colour_by = celltype_viz, colour = colour_key, save_plot = fn)
  })
})
```



# **Consensus cell types**

Attribute consensus cell types for non-islet cells based on the clustering performed above.


## Cell type concordance

Compare concordance of cell types attributed using different methods.

```{r celltypes-concordance}
celltype_cols <- colnames(colData(sce_exo))[grepl(paste0(
  "CellType_", methods_sel, collapse = "|"), colnames(colData(sce_exo)))]

celltype_cols <- celltype_cols[!celltype_cols %in% c("CellType_Leiden2_fastMNN_case_id")]

celltypes <- as.data.table(colData(sce_exo)[
  , c("cell_id", "case_id", "image_number", "cell_number", celltype_cols)])


ct_combination <- t(combn(unique(celltype_cols), 2))

for (i in seq_len(nrow(ct_combination))) {
  cat("\n", ct_combination[i, 1], " vs ", ct_combination[i, 2], "\n")
  
  ct_concord <- nrow(
    celltypes[get(ct_combination[i, 1]) == get(ct_combination[i, 2]), ]
  )
  ct_discord <- nrow(
    celltypes[get(ct_combination[i, 1]) != get(ct_combination[i, 2]), ]
  )
  cat("Number of cells with concordant cell types: ", ct_concord,
      "\nNumber of cells with discordant cell types: ", ct_discord,
      "\nPercentage of cells with concordant cell types:",
      100 * ct_concord / (ct_discord + ct_concord), "%", "\n")
}
```
Pheno2scaled vs Pheno2fastMNN_case_id:  74 %
Pheno2scaled vs Leiden2scaled:  93 %
Pheno2scaled vs Leiden2fastMNN_case_id:  69 %
Pheno2fastMNN_case_id vs Leiden2scaled:  75 %
Pheno2fastMNN_case_id vs Leiden2fastMNN_case_id:  80 %
Leiden2scaled vs Leiden2fastMNN_case_id:  70 %


## Attribute consensus cell types

### Majority vote

Cells for which 3 out of 4 methods agree on the cell type are attributed this cell type, other cells as considered as "Ambiguous".

```{r consensus-celltype}
# Majority vote
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

celltypes[, cell_type := apply(celltypes, 1, Mode)]
celltypes[, Paste := do.call(paste0, .SD),
          .SDcols = grep("CellType_", colnames(celltypes))]
celltypes[, count := stringr::str_count(Paste, cell_type)]
celltypes[count < 2, cell_type := "Ambiguous"]
#celltypes[, `:=`(Paste = NULL, count = NULL)]

cat("Percentage of cells with an ambiguous cell type: ",
    100 * nrow(celltypes[cell_type == "Ambiguous"]) / nrow(celltypes),
    "%")
```
Ambiguous = 1.6 %; Other = 1.6 % (probably most other immune cells?)
```{r consensus-celltype-print}
celltypes |> 
  as_tibble() |>
  group_by(cell_type)  |> 
  mutate(n_cell = n())  |> 
  ungroup() |> 
  group_by(cell_type, count, n_cell) |>
  # freq. per cell_type.
  summarise(n = n() / dplyr::first(n_cell)) |>
  print(n = "all")
```
### Compare cell type attributions

```{r celltypes-alluvial, warning=FALSE}
celltype_cols <- c("cell_type", colnames(colData(sce_exo))[grepl(paste0(
  "CellType_", methods_sel, collapse = "|"), colnames(colData(sce_exo)))])
celltype_cols <- celltype_cols[!celltype_cols %in% c("CellType_Leiden2_fastMNN_case_id")]

p <- celltypes[, .(number = .N), by = celltype_cols] |>
  ggplot(aes(axis1 = get(celltype_cols[1]),
             axis2 = get(celltype_cols[2]),
             axis3 = get(celltype_cols[3]),
             axis4 = get(celltype_cols[4]),
             #axis5 = get(celltype_cols[5]),
             y = number)) +
  geom_stratum() +
  geom_text(stat = "stratum", infer.label = TRUE) +
  geom_alluvium(aes(fill = get(celltype_cols[1]))) +
  scale_x_discrete(limits = gsub("cell_type_", "", celltype_cols)) +
  scale_fill_manual(values = palettes$colors[c(TRUE, FALSE)],
                    name = "Cell Type") +
  mytheme$standard() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
if (do_print) { 
  print(p)
}

fn <- paste0(paste(today, "CellTypes", "alluvial", sep = "_"), ".png")
do.call(ggsave, c(list(fn, p), plotsave_param))
```

### Number of cells by cell type

```{r cells-per-celltype}
tibble::as_tibble(celltypes) |>
  dplyr::select(cell_type) |>
  dplyr::group_by(cell_type) |>
  dplyr::add_count(name = "Number of cells") |>
  dplyr::distinct()
```


## Add celltyes to the non-islet SCE object

```{r add-non-islet-celltypes-sce}
celltypes <- celltypes[order(match(celltypes$cell_id, colnames(sce_exo))), ]
colData(sce_exo)$cell_type <- celltypes$cell_type
```


## Add cell categories

```{r add-cellcat}
exocrine_celltypes <- c("Acinar", "Ductal")
immune_celltypes <- c("Tcell", "Macrophage")

sce_exo$cell_category <- ifelse(
  sce_exo$cell_type %in% exocrine_celltypes, "exocrine", ifelse(
    sce_exo$cell_type %in% immune_celltypes, "immune", ifelse(
      sce_exo$cell_type == "Endothelial", "endothelial", ifelse(
        sce_exo$cell_type == "Mesenchymal", "mesenchymal", ifelse(
          sce_exo$cell_type == "IsletLike", "isletlike", "other")))))
```



# **Plot cell types**

## Reduced dimensions

Plot consensus cell types on reduced dimensions

```{r consensus-dimred}
ct <- c(names(palettes$celltype), "Ambiguous")
palette_ct <- c(palettes$celltype[1:(length(ct) - 2)], "grey40", "grey")
names(palette_ct) <- names(ct) <- ct

cur_dat <- scuttle::makePerCellDF(
  sce_exo[, colnames(sce_exo) %in% meta[["subset_exo"]]],
  use_dimred = TRUE) |>
  dplyr::mutate(case_id = factor(case_id, levels = meta$cases),
                donor_type = factor(donor_type, levels = meta$stages),
                cell_type = factor(cell_type, levels = names(ct))) |>
  dplyr::arrange(cell_type, case_id, donor_type)

purrr::walk(assay_sel, \(cur_assay) {
  purrr::walk(dimred_sel, \(cur_dimred) {
    dimred_name <- paste(cur_dimred, cur_assay, sep = "_")
    
    p <- plot_dim_red(cur_dat, dimred_name, "cell_type",
                      sample = TRUE, size = 0.1, alpha = 1,
                      palette = palette_ct)
    if (do_print) { 
      print(p)
    }
    
    fn <- paste0(paste(today, "CellType", "Consensus", dimred_name,
                       sep = "_"), ".png")
    do.call(ggsave, c(list(fn, p), plotsave_param))
  })
})
remove(cur_dat)
```

## Heatmap

```{r consensus-heatmap}
hmlist <- list()
purrr::walk2(assay_sel, names(assay_sel), \(cur_assay, name_cur_assay) {
  clust_name <- paste("CellType", cur_assay, sep = "_")
  
  # Summarize the data
  hm <- summarize_heatmap(sce_exo,
                          expr_values = name_cur_assay,
                          cluster_by = "cell_type",
                          channels = channels)
  
  # Display the heatmap
  fn <- paste0(paste(today, "CellType", "Consensus", cur_assay,
                     "Heatmap", sep = "_"), ".html")
  
  hmlist[[i]] <- heatmaply(
    heatmaply::normalize(hm), main = clust_name,
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```


## Correlation between channels

```{r celltype-correlation}
# Define the correlation method
cor_method <- "pearson"

# Function to calculate p values
cor_test_p <- function(x) {
  FUN <- function(x, y) cor.test(x, y, method = cor_method)[["p.value"]]
  z <- outer(
    colnames(x), 
    colnames(x), 
    Vectorize(function(i, j) FUN(x[, i], x[, j]))
  )
  dimnames(z) <- list(colnames(x), colnames(x))
  z
}

hmlist <- list()
purrr::walk(assay_sel, \(cur_assay) {
  
  # Summarize the data
  hm <- summarize_heatmap(sce_exo,
                          expr_values = cur_assay,
                          cluster_by = "cell_type",
                          channels = channels)
  
  # Run the correlation test
  r <- cor(hm, method = cor_method)
  p <- cor_test_p(hm)
  diag(p) <- NA
  
  # Plot and save the heatmap
  fn <- paste0(paste(today, "CellTypes", "Consensus", "Correlation",
                     cur_assay, sep = "_"), ".html")
  
  hmlist[[i]] <- heatmaply_cor(
    r, node_type = "scatter",
    point_size_mat = -log10(p), point_size_name = "-log10(p-value)",
    label_names = c("x", "y", "Correlation"),
    main = paste("Cell type -", cur_assay),
    file = file.path(paths$folder_script, fn))
})
htmltools::tagList(setNames(hmlist, NULL))
```



# **Finalize and save **

## Merge objects

Merge the "islet" and "non-islet" SCE objects, convert to SPE.

```{r merge-spe}
# Merge and re-order
spe <- cbind(sce_isl, sce_exo)
spe <- spe[, order(colData(spe)$case_id,
                   colData(spe)$image_number,
                   colData(spe)$cell_number)]

# Fix sample_id and convert to SPE
spe$sample_id <- spe$image_id
spe <- as(spe, "SpatialExperiment")

# Add the saved metadata and spatial coordinates
metadata(spe) <- meta
spatialCoords(spe) <- spatial_coords
colPairs(spe) <- colpairs
remove(sce_isl, sce_exo)
```


## Save the updated SCE object

Contains all attributed cell types and cell categories

```{r save-spe}
fn_spe <- file.path(paths$folder_script, paste0(paths$object_type, "_", paths$panel_type, ".rds"))
print(spe)
saveRDS(spe, fn_spe)
```
